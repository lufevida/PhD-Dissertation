%--------------------------------------------------------------------------
\chapter{THEORETICAL FRAMEWORK}

%TODO: This problem is NP-hard and is a satisfiability problem similar to Sudoku and the 8-Queens.

%--------------------------------------------------------------------------
\section{Defining an algorithm to compute a row class}

%--------------------------------------------------------------------------
In a traditional setting, a composer will usually define a class of transforms of a basic row by computing by hand what is commonly denoted a 12-tone matrix. The general procedure usually consists of filling the top row of the matrix with a transform of the 12-tone row beginning with zero. The second step is to fill the leftmost column of the matrix with the inverse transform of the top row. The subsequent steps comprise going row-by-row, filling them with a transposition of the top row. The particular transposition for each 12-tone row is given by the first element of the matrix row at hand, which in turn corresponds to an element in the leftmost column. The 12-tone matrix will hold all 48 transforms of a row: reading every row from left to right gives all transpositions, reading them from right to left gives all retrogrades, reading all columns from top to bottom gives all inversions, and reading them from bottom to top gives all retrograde inversions. Although somewhat tedious, computing 12-tone matrices by hand is a well-established procedure. The 48 transforms that can be inferred from the matrix are not necessarily unique, given that a 12-tone may be retrograde, or retrograde-inverse invariant. It is straightforward to generalize the procedure to $n$-tone matrices. However, the graphical idea of reading the matrix from right to left, or bottom to top, is not ideal for computing self-deriving combination matrices, as it is faster to read a transform of a row that is written contiguously in memory. Another caveat is that the procedure does not necessarily define a canonical form for the top row. Every row in a matrix is a representative of an equivalence class of rows under the action of $RT_nI \cong D_{24} \oplus \mathbb{F}_2$ \cite[127]{FripertingerLackner2015}. The size of each orbit is $4n$ if the row is not retrograde or retrograde-inverse invariant, and $2n$ otherwise. Defining a canonical form for the first row in a data structure that holds a row class is desirable in any algorithm that iterates through row classes in lexicographic order.

%--------------------------------------------------------------------------
Listing~\ref{getCanonicalForm} describes an algorithm that produces a canonical form for a row. The canonical form defined in this implementation is simply the least element in a lexicographic ordering of a row class. Given an arbitrary representative of a row class, that representative will be considered retrograded if any interval class between two consecutive elements of the row, counted from right to left, is strictly less than the corresponding interval class counted from left to right. Most procedures described in this chapter and the next rely on aliases for certain primitive data types, which are given Listing~\ref{typedefs}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Defining aliases for common primitive data types.},label={typedefs}]
typedef signed char number;
typedef unsigned short range;
typedef unsigned long length;
\end{lstlisting}

%TODO: explain how these primitives were chosen

%--------------------------------------------------------------------------
Finding the interval class between two pitch-classes is illustrated in Listing~\ref{intervalClass}, which takes as input two pitch-classes $a$ and $b$, and the base $n$, returning the interval class between the two. The interval class between $a \pmod n$ and $b \pmod n$ is expressed mathematically as $\min\{(a - b) \pmod n, (b - a) \pmod n\}$.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Computing the interval class between two pitch-classes.},label={intervalClass}]
number intervalClass(number a, number b, number rowSize) {
    number interval = abs(a - b);
    return min(interval, rowSize - interval);
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item Listing~\ref{intervalClass} takes as input two pitch-classes $a$ and $b$, as well as a base $n$ such that $a, b \in \mathbb{Z} / n \mathbb{Z}$.
\item Line 2 simply computes the distance between $a$ and $b$.
\item Line 3 returns the least between the interval computed in line 2 and its complement, that is, the interval class between the two given pitch-classes.
\end{enumerate}

%--------------------------------------------------------------------------
The procedure for determining whether a row is retrograded utilizes Listing~\ref{intervalClass} as a subroutine and is outlined in Listing~\ref{isRetrograded}. The first parameter taken by Listing~\ref{isRetrograded} is the row at hand, which can be any representative of its row class.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a representative of a row class is retrograded.},label={isRetrograded}]
bool isRetrograded(const number *row, number rowSize, bool isInvariant) {
    if (isInvariant || rowSize < 5)
        return false;

    number front, back;

    for (number i = 0; i < rowSize / 2; ++i) {
        front = intervalClass(row[i + 1], row[i], rowSize);
        back = intervalClass(row[rowSize - i - 1], row[rowSize - i - 2], rowSize);

        if (back < front)
            return true;
        else if (back > front)
            return false;
    }

    return false;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item Listing~\ref{isRetrograded} has three parameters, namely a pointer to a row, its size, and a boolean representing whether the row is retrograde or retrograde inverse-invariant. The returned value is another boolean indicating whether the row is retrograded or not.
\item Lines 2 and 3 perform a sanity check. It is straightforward to see that all rows of size 4 or less are necessarily retrograde or retrograde inverse-invariant. If, on the other hand, a row with 5 or more elements is known to be invariant, the test is also skipped.
\addtocounter{enumi}{2}
\item Line 5 declares the variables that will represent the row's interval classes seen from left to right, and from right to left, respectively.
\addtocounter{enumi}{2}
\item Lines 8 and 9 simply update the variables \emph{front} and \emph{back} using Listing~\ref{intervalClass} defined above. As $i$ increases, \emph{front} traverses half of the interval classes in the row from left to right, whereas \emph{back} does the same from right to left, that is, \emph{back} looks at the row as if it were retrograded.
\addtocounter{enumi}{2}
\item Line 11 compares the front and back interval classes and line 12 returns true if any interval class seen from right to left is strictly less than the corresponding interval class seen from left to right, which would indicate that retrograding the row would produce a row with a lower lexicographic position than the one given as input.
\addtocounter{enumi}{1}
\item Line 13 performs the opposite check in line 11 and line 14 returns true in this case, as the given row is already in a lower lexicographic position than its retrograde.
\addtocounter{enumi}{3}
\item If all interval classes seen from both directions are equal, then the row is retrograde or retrograde inverse-invariant. Line 17 then returns false to avoid unnecessarily reversing a row that is invariant. However, line 17 exists for correctness and should never be reached when the row given as input is correctly formed.
\end{enumerate}

%--------------------------------------------------------------------------
The next step in determining the canonical form of a row consists of finding whether its inverse has a lower lexicographic position within the row class. The procedure is described in Listing~\ref{isInverted}, which in turn depends on two small subroutines, namely Listing~\ref{modulo} and Listing~\ref{isOwnInverse}. The former simply computes $modulo(x, n) = x \pmod{n}$. However, it needs to be defined as a subroutine this way because the result of the C-language built-in modulo operator is signed, and for practical reasons that will be elaborated in the next sections, it is best that all pitch-classes be represented as unsigned integers ranging from $0$ to $n - 1$.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={A subroutine to compute $x \pmod{n}$ such that the result is non-negative.},label={modulo}]
number modulo(number x, number base) {
    x %= base;
    return x < 0 ? x + base : x;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs to Listing~\ref{modulo} are a number $x$ and a base $n$.
\item Line 2 simply computes $x \pmod{n}$ using the C-language built-in modulo operator.
\item Line 3 then returns the congruence class in the range $[0, n - 1]$.
\end{enumerate}

%--------------------------------------------------------------------------
Listing~\ref{isOwnInverse} is a simple convenience method that is used to check whether $x \equiv x \pmod{n}$, which is also needed in Listing~\ref{isInverted}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={A subroutine that returns true if a pitch-class is its own inverse.},label={isOwnInverse}]
bool isOwnInverse(number x, number base) {
    return x == 0 || x == base - x;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The input $x$ is assumed to be in the range $[0, n - 1]$.
\item Since $x$ is non-negative, it can only be its own inverse if it is the identity, or if $x \equiv -x \pmod{n}$. It is also possible to check that if $n$ is even and $x$ is equal to $n / 2$, then $x$ is its own inverse. But this alternative method is more expensive that the computation performed in line 2.
\end{enumerate}

%--------------------------------------------------------------------------
In order to determine whether the inverse transform of a row has a lower lexicographic position than itself, it is necessary in this implementation to consider if its retrograde transform also sits in a lower lexicographic position. Therefore a call to Listing~\ref{isInverted} requires a previous call to Listing~\ref{isRetrograded}, since the result of the latter is used as the last argument passed to Listing~\ref{isInverted}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a representative of a row class is inverted.},label={isInverted}]
bool isInverted(const number *r, number rowSize, bool R) {
    if (R) {
        for (number i = rowSize - 1; i >= rowSize / 2; --i) {
            number mod = modulo(r[i] - r[rowSize - 1], rowSize);

            if (!isOwnInverse(mod, rowSize))
                return mod > rowSize - mod;
        }
    } else {
        for (number i = 0; i < rowSize / 2; ++i) {
            number mod = modulo(r[i] - r[0], rowSize);

            if (!isOwnInverse(mod, rowSize))
                return mod > rowSize - mod;
        }
    }

    return false;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are a row, its size, and a boolean representing whether the row is retrograded.
\addtocounter{enumi}{1}
\item If $r$ is retrograded, line 3 begins iteration in reverse order, that is, starting with the last element of the row.
\item Line 4 computes the ordered interval between the pitch-class at hand, and the first pitch-class of the row, which in this case is the last because the row is retrograded.
\addtocounter{enumi}{1}
\item Line 6 checks if the interval is not its own inverse and, if not, line 7 checks if the interval is greater than its inverse. If so, an inverted form of the row would sit in a lower lexicographic position within the entire row class, and the row is inverted.
\addtocounter{enumi}{3}
\item If the input row is not retrograded, then lines 10 to 14 perform essentially the same check as the previous branch, only traversing the row from left to right, instead of the right to left traversal done for a retrograded row. In both branches, it is important to note that the loops iterate at most twice. If the row size is odd, then the very first iteration will decide if the row is inverted. If, on the other hand, the row size is even, then there is the possibility that the very first interval will be its own inverse, in which case the next iteration will invariably be able to tell if the row is inverted.
\addtocounter{enumi}{7}
\item Line 18 should never be reached for well-defined inputs, and is included for correctness.
\end{enumerate}

%--------------------------------------------------------------------------
Determining that an arbitrary representative of a row class is retrograded or inverted are essential subroutines used in Listing~\ref{getCanonicalForm}, which in turn does transform the input row into its canonical form. This transformation happens in Listing~\ref{getTransformInPlace}, and the latter relies on a straightforward method to swap row entries in place, which is described below in Listing~\ref{swapInPlace}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Swapping two entries in a row.},label={swapInPlace}]
void swapInPlace(number *row, number i, number j) {
    number tmp = row[i];
    row[i] = row[j];
    row[j] = tmp;
}
\end{lstlisting}

%--------------------------------------------------------------------------
The procedure in Listing~\ref{swapInPlace} is very common-place, so the details are omitted. Listing~\ref{getTransformInPlace} is also straightforward and represents the main subroutine in Listing~\ref{getCanonicalForm}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Transforming a row in place.},label={getTransformInPlace}]
void getTransformInPlace(number *row, number rowSize, number T, bool I, bool R) {
    if (R) {
        for (number i = 0; i < rowSize / 2; ++i)
            swapInPlace(row, i, rowSize - 1 - i);
    }

    if (I) {
        for (number i = 0; i < rowSize; ++i)
            row[i] = (rowSize - row[i] + T) % rowSize;
    } else if (T != 0 % rowSize) {
        for (number i = 0; i < rowSize; ++i)
            row[i] = (row[i] + T) % rowSize;
    }
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are a row, its size, a non-negative integer representing an offset to be added to the entire row, a boolean representing whether the row is inverted, and another boolean representing whether the row is retrograded.
\addtocounter{enumi}{1}
\item If the row is retrograded, lines 3 and 4 simply reverse the row using Listing~\ref{swapInPlace}.
\addtocounter{enumi}{4}
\item If the row is inverted, lines 8 and 9 invert the row and add the offset to each row entry.
\addtocounter{enumi}{2}
\item Otherwise, if the row is not inverted, lines 11 and 12 only add the offset to the entire row.
\end{enumerate}

%--------------------------------------------------------------------------
The procedure illustrated in Listing~\ref{getTransformInPlace} is used below in Listing~\ref{getCanonicalForm}, but it will also be used many times over to construct a row class in memory. In the particular case where the canonical form of the row is desired, that is, the lowest element in a lexicographic ordering of the row class, the offset used will be the additive inverse of the row's first element. It is important to observe that Listing~\ref{getCanonicalForm} requires prior knowledge as to whether the row is retrograde or retrograde inverse-invariant. In the grand scheme of things, that knowledge will already be available when calling Listing~\ref{getCanonicalForm}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Transforming a row into its canonical form.},label={getCanonicalForm}]
void getCanonicalForm(number *row, number rowSize, bool isInvariant) {
    bool R = isRetrograded(row, rowSize, isInvariant);
    bool I = isInverted(row, rowSize, R);
    number T = row[R ? rowSize - 1 : 0];
    getTransformInPlace(row, rowSize, I ? T : rowSize - T, I, R);
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are a row, its size, and whether the row is retrograde or retrograde inverse-invariant.
\item Lines 2 and 3 simply call Listing~\ref{isRetrograded} and Listing~\ref{isInverted} respectively, storing the results.
\addtocounter{enumi}{1}
\item Line 4 just stores the first element of the row, which may be the last if the row is retrograded.
\item Line 5 is a call to Listing~\ref{getTransformInPlace}. The third argument is the additive inverse of the row's start element. It varies, naturally, if the row is inverted.
\end{enumerate}

%--------------------------------------------------------------------------
The purpose of the procedure described in Listing~\ref{getRowClass} is to store an entire row class contiguously in memory. That consists of creating an array large enough to hold all transforms of a row, and sequentially copying said transforms into this array. Even for rows whose bases are considered large, a row class under $RTn_I$ is still very small. Thus holding these transforms in memory makes sense for execution speed purposes. The size of the row class array depends on whether the row is reverse or reverse inverse-invariant. The row class array begins with the canonical form of the row, followed by all its transpositions, in ascending order, followed by all transpositions of the inversion of the canonical form, also in ascending order. If the row is not reverse or reverse inverse-invariant, the row class array is appended by all transpositions of the reverse of the canonical order, followed by all transpositions of the retrograde inverse of the canonical order. Therefore, the overall size of the row class array is $2n^2$ if the row is retrograde or retrograde inverse-invariant, or $4n^2$ otherwise, where $n$ is the row size. The main routine for creating the row class array is described in Listing~\ref{getRowClass}. It depends on two subroutines, namely Listing~\ref{isRetrogradeInvariant} and Listing~\ref{isRetrogradeInverseInvariant} that are described below.

%--------------------------------------------------------------------------
\begin{lemma}
	\label{retrograde-invariance}
	In a retrograde-invariant row, the interval between every entry seen from left to right, and the corresponding entry seen from right to left, must equal half the size of the row. In particular, a row with odd size greater than $3$ cannot be retrograde-invariant.
	\begin{proof}
	Regard the row as a sequence of order numbers $\{0, 1, \cdots, n - 1\}$. If $n$ is even, the retrograde operation induces the permutation of order numbers
	\begin{equation}
		P = (0 \; n - 1) \; (1 \; n - 2) \; \cdots \; (\tfrac{n}{2} - 1 \; \tfrac{n}{2}) \enspace .
	\end{equation}
	If $n$ is odd, the retrograde operation induces the permutation of order numbers
	\begin{equation}
		P = (0 \; n - 1) \; (1 \; n - 2) \; \cdots \; (\lfloor \tfrac{n}{2} \rfloor) \enspace .
	\end{equation}
	Since $P$ is a transposition, the only possibility is $P = T_{\frac{n}{2}}$, with $n$ even.
	\end{proof}
\end{lemma}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a row is retrograde-invariant.},label={isRetrogradeInvariant}]
bool isRetrogradeInvariant(const number *row, number rowSize) {
    if (rowSize > 4 && rowSize % 2 == 1)
        return false;

    number half = rowSize / 2;

    for (number i = 0; i < half; ++i) {
        if (modulo(row[rowSize - i - 1] - row[i], rowSize) != half)
            return false;
    }

    return true;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The only inputs are a row and its size.
\item Line 2 utilizes Lem.~\ref{retrograde-invariance} as a sanity check. If the test in line 2 succeeds, line 3 returns false.
\addtocounter{enumi}{2}
\item Line 5 just computes half the row size for convenience. Retrograde-invariance can be determined by iterating through at most half the size of the row.
\addtocounter{enumi}{1}
\item Line 7 iterates through the row from left to right, and line 8 applies Lem.~\ref{retrograde-invariance}. Line 9 then returns false if any of the intervals is not equal to half the row size.
\addtocounter{enumi}{4}
\item If all pairs coming from both directions are equal to half the row size, then the row is retrograde-invariant and line 12 returns true.
\end{enumerate}

%--------------------------------------------------------------------------
Unlike retrograde invariance, every row size can produce retrograde inverse-invariant rows. A simple example is the row of any size with the lowest lexicographic order. If $n = 12$, this is a chromatic scale. Retrograding, inverting, and transposing by $-1$ always yields back the initial row. Listing~\ref{isRetrogradeInverseInvariant} outlines the procedure in all generality.

%--------------------------------------------------------------------------
\begin{lemma}
	\label{retrograde-inverse-invariance}
	In a retrograde inverse-invariant row $r$, the sum of every entry seen from left to right, and the corresponding entry seen from right to left, must be equal to $x = r_0 + r_{n - 1} \pmod{n}$, where $n$ is the base of the row. In particular, if $n$ is odd, the element at the center of the row plus itself must also be equal to $x$. 
	\begin{proof}
	The index of inversion between two pitch-classes is their sum. To see that, let $a$ and $b$ be pitch-classes. It follows
	\begin{equation}
		a = T_xI(b) \iff a = T_x(-b) \iff a = x - b \iff a + b = x \enspace .
	\label{eq:retrograde-inverse-invariance}
	\end{equation}
	If $x = r_0 + r_{n - 1} \pmod{n}$, then $x$ is the index of inversion between the first and last elements of $r$. Since $r$ is retrograde inverse-invariant, this forces every pair of corresponding elements in $r$ from both directions to have the same index of inversion. If $n$ is odd, the element $c$ at the center must be invariant under $T_xI$, since it is a fixed point under $R$. By Eq.~\ref{eq:retrograde-inverse-invariance}, $c = T_xI(c) \iff c + c = x$, as desired.
	\end{proof}
\end{lemma}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a row is retrograde inverse-invariant.},label={isRetrogradeInverseInvariant}]
bool isRetrogradeInverseInvariant(const number *row, number rowSize) {
    number half = rowSize / 2;
    number first = modulo(row[rowSize - 1] + row[0], rowSize);

    for (number i = 1; i < half; ++i) {
        if (modulo(row[rowSize - i - 1] + row[i], rowSize) != first)
            return false;
    }

    return true;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are a row and its size.
\item Line 2 computes half the row size for convenience. Like Listing~\ref{isRetrogradeInvariant}, retrograde inverse invariance can be determined by traversing at most half the row size.
\item Line 3 computes $r_0 + r_{n - 1} \pmod{n}$ for later use.
\addtocounter{enumi}{1}
\item Line 5 begins iteration from the second entry onward, since the first pair was already computed in line 3. Line 6 then compares the subsequent corresponding pairs, and line 7 returns false if any of them is not equal to the first pair.
\addtocounter{enumi}{4}
\item If line 10 is reached, it means the row is retrograde inverse-invariant, so the algorithm returns true.
\end{enumerate}

%--------------------------------------------------------------------------
The procedure to compute and store an entire row class in memory is outlined below in Listing~\ref{getRowClass}. It returns a memory address that must be freed by the caller. While computing combination matrices of self-derivation, this memory location will be held for the duration of the program, and possibly also be shared by many different threads of execution. The procedure makes heavy use of Listing~\ref{getTransformInPlace} to sequentially store in memory all transforms of the canonical form of the row. It also takes the input row and transforms it in-place into its canonical form. Any representative of a row class can therefore be used to construct a row class with Listing~\ref{getRowClass}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Computing and storing a row class in memory.},label={getRowClass}]
number *getRowClass(range *classSize, number *row, number rowSize, bool isInvariant) {
    getCanonicalForm(row, rowSize, isInvariant);
    *classSize = isInvariant ? rowSize * 2 : rowSize * 4;

    number *rowClass = malloc(rowSize * *classSize * sizeof(number));
    memcpy(rowClass, row, rowSize * sizeof(number));

    for (number i = 1; i < rowSize; ++i) {
        number *rep = &rowClass[i * rowSize];
        memcpy(rep, rowClass, rowSize * sizeof(number));
        getTransformInPlace(rep, rowSize, i, false, false);
    }

    for (number i = rowSize; i < rowSize * 2; ++i) {
        number *rep = &rowClass[i * rowSize];
        memcpy(rep, rowClass, rowSize * sizeof(number));
        getTransformInPlace(rep, rowSize, i, true, false);
    }

    if (*classSize == rowSize * 2)
        return rowClass;

    for (number i = rowSize * 2; i < rowSize * 3; ++i) {
        number *rep = &rowClass[i * rowSize];
        memcpy(rep, rowClass, rowSize * sizeof(number));
        getTransformInPlace(rep, rowSize, i, false, true);
    }

    for (number i = rowSize * 3; i < rowSize * 4; ++i) {
        number *rep = &rowClass[i * rowSize];
        memcpy(rep, rowClass, rowSize * sizeof(number));
        getTransformInPlace(rep, rowSize, i, true, true);
    }

    return rowClass;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are a pointer to the size of the row class, which will be computed by Listing~\ref{getRowClass} and stored in the address provided, a row, its size, and a boolean representing whether the row is retrograde or retrograde inverse-invariant. This boolean will be computed by the caller before calling Listing~\ref{getRowClass}, utilizing the procedures described in Listing~\ref{isRetrogradeInvariant} and Listing~\ref{isRetrogradeInverseInvariant}. The output is a memory location containing the entire row class.
\item As mentioned above, line 2 simply computes the canonical form of the given row in place.
\item Line 3 computes the class size based on whether the row is retrograde or retrograde inverse-invariant. It is important to notice here that the row class size is not the length of the row class array, but the number of transforms of the canonical form that the row class array contains. This number is stored in the address provided by the caller.
\addtocounter{enumi}{1}
\item Line 5 allocates in the heap the memory space that will be used to store the entire row class, and line 6 copies the canonical form of the row to the beginning of this allocated space.
\addtocounter{enumi}{2}
\item Line 8 starts from the second row in the row class, which is the first transposition of the canonical form, and the block adds all subsequent transpositions to the row class. Line 9 computes the address where the current transposition should start, line 10 copies the canonical form of the row into this address, and line 11 transforms the canonical form into the desired transposition in place. 
\addtocounter{enumi}{5}
\item Line 14 starts from the $n$\textsuperscript{th} row in the row class, that is, the $T_0I$ transform of the row. Lines 15 to 17 add the subsequent $T_nI$ transforms of the canonical form of the row in the same way the $T_n$ transforms were added above, only specifying in the call to Listing~\ref{getTransformInPlace} that the transforms now need to be inverted.
\addtocounter{enumi}{5}
\item Line 20 checks if the row is retrograde or retrograde inverse-invariant and, if so, halts the process and returns the memory location allocated in line 5.
\addtocounter{enumi}{2}
\item If the row is is retrograde or retrograde inverse-invariant, lines 23 to 26 add all $RT_n$ transforms of the row to the row class as above.
\addtocounter{enumi}{5}
\item Similarly, lines 29 to 32 add all the $RT_nI$ transforms of the row.
\addtocounter{enumi}{5}
\item Line 36 then simply returns the memory location allocated in line 5.
\end{enumerate}

%--------------------------------------------------------------------------
\section{Defining an algorithm to compute semi-magic squares}

%--------------------------------------------------------------------------
A key component in the definition of a combination matrix of self-derivation is a semi-magic square. By definition, a semi-magic square is a square matrix where the sum of all elements, for each row and column, is a constant. For the purposes of this implementation, that constant will be the base $n$ of the row. Seeing each entry in a semi-magic square as a real number and dividing each entry in the matrix by $n$ produces a doubly stochastic matrix, in which every row and every column sum to one. A magic square is a semi-magic square where, in addition, both main diagonals add up to the same constant as the rows and columns. By the above definition of a semi-magic square, every row therein is a permutation of an integer partition of $n$. In fact, every column is also a permutation of an integer partition of $n$, but the algorithm described in Listing~\ref{allPartitionsRecursive} shall concentrate on computing all integer partitions of $n$ and their permutations as rows that will ultimately become the rows of a semi-magic square. Since these integer partitions of $n$ are completely independent of the row at hand, they can be computed only once for each $n$ and stored as a file, speeding up the process of computing combination matrices for other rows. Before describing Listing~\ref{allPartitionsRecursive}, a couple subroutines for reading and writing files are outlined.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Retrieving the size of a file.},label={getFileSize}]
long getFileSize(FILE *file) {
    fseek(file, 0, SEEK_END);
    long fileSize = ftell(file);
    fseek(file, 0, SEEK_SET);
    return fileSize;
}
\end{lstlisting}

%--------------------------------------------------------------------------
Listing~\ref{getFileSize} is a completely common-place procedure in the C-language, and its details are omitted. It is used as a subroutine in Listing~\ref{readFile}, which is described next.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Reading the contents of a file.},label={readFile}]
number *readFile(const char *fileName, length *numLines, number problemSize) {
    FILE *file = fopen(fileName, "rb");

    if (file == NULL)
        return NULL;

    long fileSize = getFileSize(file);
    number *buffer = malloc(fileSize);
    *numLines = (length) (fileSize / sizeof(number)) / problemSize;
    fread(buffer, fileSize, 1, file);
    fclose(file);

    return buffer;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the file name, assuming both the main executable and the file are in the same folder, a memory address where the number of lines read will be stored, and the problem size, which is the size of the magic square. The output is a memory location with the contents of the file, or a null pointer if the operation fails.
\item Line 2 simply opens the file at the given path for reading. Line 4 performs a sanity check and line 5 returns a null pointer if the file cannot be read.
\addtocounter{enumi}{4}
\item Line 7 is a call to Listing~\ref{getFileSize} so that the correct amount of memory can be allocated. The value computed in line 7 is already in bytes. Line 8 then allocates the memory space whose address will be returned.
\addtocounter{enumi}{1}
\item Line 9 computes the number of lines in the file, that is, the number of integer partitions of $n$ with length \emph{problemSize} that have been previously computed and stored in the file. The value is then stored in the memory address provided in the input list to store the number of lines in the file.
\item Line 10 simply reads the entire contents of the file into the buffer allocated in line 8, line 11 frees the FILE data structure created in line 2, and line 13 returns the allocated memory. It is the responsibility of the caller to free this memory when no longer needed.
\end{enumerate}

%--------------------------------------------------------------------------
The procedure described in Listing~\ref{writeAllPartitions} effectively writes all integer partitions of $n$ with a certain size to a file. It depends on Listing~\ref{allPartitionsRecursive} to compute all said partitions recursively, which is described next. One important feature of Listing~\ref{allPartitionsRecursive} is that it skips partitions whose all but one entries are zero. The reason for this is because the remaining entry would be forced to be equal to $n$. In any semi-magic square where there is an entry equal to $n$, both the row and column to which this entry belongs will necessarily contain only zeros except, of course, for the entry itself with value $n$. This means that the linearized top of the combination matrix at that semi-magic square's column will inevitably be trivially polyphonized, that is, the corresponding square cell would simply contain the entire row at the top. Therefore any combination matrix can be extended by adding a column and a row at arbitrary indices, and making the square entry at the intersection of the newly-added row and column contain $n$ elements, that is, a linearized statement of a row form. Since this procedure is completely general, the semi-magic squares computed below include entries only up to $n - 1$.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all partitions of a number $n$ and permutations thereof with a certain size.},label={allPartitionsRecursive}]
void allPartitionsRecursive(number *tmp, number currentSize, number problemSize, number currentSum, number rowSize, FILE *file) {
    if (currentSize == problemSize - 1) {
        if (currentSum > 0) { // skip the [0, ..., 0, rowSize] partition
            tmp[currentSize] = rowSize - currentSum;
            fwrite(tmp, sizeof(number), problemSize, file);
        }

        return;
    }

    for (number i = 0; i < rowSize; ++i) {
        if (i + currentSum <= rowSize) {
            tmp[currentSize++] = i;
            allPartitionsRecursive(tmp, currentSize, problemSize, i + currentSum, rowSize, file);
            currentSize--;
        }
    }
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the address of some scratch memory previously allocated with the same length of the problem size, the current number of entries already placed in the scratch memory, the problem size, the current sum of the entries in the scratch memory, the base $n$, and a pointer to a FILE data structure where the partitions will be stored, line by line.
\item Line 2 deals with the base case of the recursion, that is, when the current number of elements in the scratch memory is one less than the problem size. If that is the case, then the last element in the scratch memory array must be equal to $n$ minus the sum of all previous elements.
\item Line 3 deals with the edge case where all entries up to problem size minus one are zero. That would force the very last element of the scratch memory array to be equal to $n$ which, by the discussion above is avoided in this implementation.
\item Line 4 sets the last element of the scratch memory array to $n$ minus the sum of its previous elements and line 5 writes the current partition to the given file. Having completed an entire partition, line 8 returns, so the function recurses no further.
\addtocounter{enumi}{6}
\item For the recursion cases where the scratch memory array has been filled with less than problem size minus one elements, the loop in line 11 iterates from zero to $n - 1$. Line 12 is a sanity check that the sum of the current element being appended to the scratch memory array with the current sum of all elements so far introduced is no greater than $n$. Line 13 then appends the current element to the end of the scratch memory array, increases the current size counter, and line 14 pushes to the call stack another recursive call to Listing~\ref{allPartitionsRecursive}.
\addtocounter{enumi}{3}
\item Line 15 backtracks the current size so that all combinations of integers in the range $[0, n - 1]$ are tried.
\end{enumerate}

%--------------------------------------------------------------------------
Listing~\ref{writeAllPartitions} described below is essentially a wrapper around Listing~\ref{allPartitionsRecursive}. Partitions files are saved in the same location where the main executable is built, in order to facilitate dealing with file paths. In general, these files are very small even for large $n$, but the speed gains in precomputing them are worthwhile, given the recursive nature of Listing~\ref{allPartitionsRecursive}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Writing all partitions to a file.},label={writeAllPartitions}]
void writeAllPartitions(number problemSize, number rowSize) {
    char fileName[32];
    sprintf(fileName, "all_partitions_%i_%i.dat", problemSize, rowSize);
    FILE *file = fopen(fileName, "wb");

    number *tmp = malloc(problemSize * sizeof(number));
    allPartitionsRecursive(tmp, 0, problemSize, 0, rowSize, file);

    free(tmp);
    fclose(file);
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are a problem size, which is the size of the semi-magic square, and a row size, which is the row base $n$.
\item Line 2 creates an array of 32 characters to hold the file name. This file name array length is large enough to accommodate all file names in this implementation. Line 3 writes the name of the file into the buffer defined in the previous line, and line 4 opens a file for writing at the specified path.
\addtocounter{enumi}{3}
\item Line 6 allocates the scratch memory needed for the call to Listing~\ref{allPartitionsRecursive} in the following line. Being that Line 7 is the bottommost call on the call stack for Listing~\ref{allPartitionsRecursive}, the arguments given for the current size and current sum parameters are both zero.
\addtocounter{enumi}{2}
\item Line 9 frees the scratch memory used in the calls to Listing~\ref{allPartitionsRecursive}, and line 10 closes and releases the file created in line 4.
\end{enumerate}

%--------------------------------------------------------------------------
The counterpart to Listing~\ref{writeAllPartitions} is Listing~\ref{readAllPartitions}, which is designed to not only read a partitions file, but to also generate one in case the particularly sought partitions file does not exist.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Reading all partitions from a file.},label={readAllPartitions}]
number *readAllPartitions(length *numPartitions, number problemSize, number rowSize) {
    char fileName[32];
    sprintf(fileName, "all_partitions_%i_%i.dat", problemSize, rowSize);

    number *allPartitions = readFile(fileName, numPartitions, problemSize);

    if (allPartitions == NULL) {
        printf("Writing partitions file...\n");
        writeAllPartitions(problemSize, rowSize);
        allPartitions = readFile(fileName, numPartitions, problemSize);
    }

    return allPartitions;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are a memory address to store the number of lines in the partitions file to be read, the problem size and the row size. The output is a memory address with the contents of the partitions file. It is the responsibility of the caller to free the returned memory when no longer needed.
\item Lines 2 and 3 store the file name in a buffer, similarly to Listing~\ref{writeAllPartitions}.
\addtocounter{enumi}{2}
\item Line 5 attempts to read an existing file.
\addtocounter{enumi}{1}
\item Line 7 checks that the operation in line 5 succeeded. If it failed, lines 8 to 10 print to the console that a partitions file will be created, create the file by calling Listing~\ref{writeAllPartitions}, and attempt to read the file again.
\addtocounter{enumi}{5}
\item Line 13 simply returns the memory address with the contents of the file, or NULL if creating the file failed.
\end{enumerate}

%--------------------------------------------------------------------------
Listing~\ref{allSquaresRecursive} describes an algorithm to combine integer partition rows into semi-magic squares. The overall procedure consists of appending integer partition rows to the square and adding the the rows as vectors. It is a backtracking recursive algorithm similar to Listing~\ref{allPartitionsRecursive}, the main difference being that the backtracking step consists of subtracting from the vector sum the previously added row after pushing onto the stack another recursive call. Adding two integer partition rows, seen as vectors, is described next in Listing~\ref{plus}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Adding two vectors.},label={plus}]
void plus(number *a, const number *b, number problemSize) {
    for (number i = 0; i < problemSize; ++i)
        a[i] += b[i];
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the memory locations of two vectors and their size, which is assumed to be the same.
\item Line 2 simply iterates through the length of the vectors and line 3 adds point-wise the second vector to the first.
\end{enumerate}

%--------------------------------------------------------------------------
The counterpart to Listing~\ref{plus} is Listing~\ref{minus}. It is important to notice that vector addition and subtraction can be vectorized for speed, that is, SIMD instructions from the processor architecture at hand can replace much of the work the for-loops in Listing~\ref{plus} is Listing~\ref{minus} do to great effect. This option is not explored in this implementation, however. Details are omitted for Listing~\ref{minus}, as it is essentially the same as Listing~\ref{plus}, only with the inverse operation.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Subtracting one vector from another.},label={minus}]
void minus(number *a, const number *b, number problemSize) {
    for (number i = 0; i < problemSize; ++i)
        a[i] -= b[i];
}
\end{lstlisting}

%--------------------------------------------------------------------------
Listing~\ref{validate} is also used as subroutine in Listing~\ref{allSquaresRecursive} to validate whether the integer partition row that has just been added to the sum-of-rows vector does not violate the semi-magic square constraints.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Validating a sum of integer partition rows.},label={validate}]
bool validate(const number *currentSum, number problemSize, number rowSize) {
    for (number i = 0; i < problemSize; ++i) {
        if (currentSum[i] > rowSize)
            return false;
    }

    return true;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the memory location of the current sum of rows, the problem size, and the row size $n$.
\item Line 2 iterates through the size of the magic square, checking in line 3 whether any entry in the current sum vector is already greater than $n$, fact that would violate the semi-magic square definition. If so, line 4 returns false.
\addtocounter{enumi}{4}
\item If all entries in the current sum vector are less than or equal to $n$, this is still a viable semi-magic square, so line 7 returns true.
\end{enumerate}

%--------------------------------------------------------------------------
Listing~\ref{allSquaresRecursive} utilizes the previously computed integer partition rows to form all possible semi-magic squares of size $n$, with entries in the range $[0, n - 1]$. It is described here because it facilitates understanding Listing~\ref{allSolutionsRecursive}, but it is not itself used in computing combination matrices of self-derivation. For the latter purpose, computing \emph{all} possible semi-magic squares would be impractical, but this discussion is deferred to the next sections. Although Listing~\ref{allSquaresRecursive} takes as input a pointer to a FILE data structure, a procedure to save all semi-magic squares is omitted, as the number of such squares is overwhelmingly large and grows with both the problem size and $n$.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all semi-magic squares of a certain size.},label={allSquaresRecursive}]
void allSquaresRecursive(number *tmp, number *currentSum, number currentSize, number problemSize, number rowSize, const number *partitions, length numPartitions, FILE *file) {
    if (currentSize == problemSize) {
        fwrite(tmp, sizeof(number), problemSize, file);
        return;
    }

    number start = 0;

    if (currentSize == 0)
        memset(currentSum, 0, problemSize * sizeof(number));
    else
        start = tmp[currentSize - 1];

    for (length i = start; i < numPartitions; ++i) {
        const number *p = &partitions[i * problemSize];
        plus(currentSum, p, problemSize);

        if (validate(currentSum, problemSize, rowSize)) {
            tmp[currentSize++] = i;
            allSquaresRecursive(tmp, currentSum, currentSize, problemSize, rowSize, partitions, numPartitions, file);
            currentSize--;
        }

        minus(currentSum, p, problemSize);
    }
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the memory address for some scratch memory where the semi-magic square will be stored as a sequence of indices into the integer partitions array. The size of this allocated memory must thus be equal to the problem size. The memory address of another scratch memory space to hold the current sum of integer partition rows, with size equal to the problem size, the current number of rows already appended to the square, the problem size, the row size $n$, a pointer to the contents of a partitions file, previously computed using Listing~\ref{allPartitionsRecursive}, the total number of integer partition rows, and a pointer to a FILE data structure.
\item Line 2 deals with the base case of the recursion, that is, when all rows have been appended to the square. When that is the case, the algorithm writes the square to the file and returns.
\addtocounter{enumi}{4}
\item Line 7 defines a variable representing where iteration of integer partition rows should start. This is a mechanism to avoid permutations of integer partition rows within a semi-magic square by enforcing that the rows of the constructed semi-magic square, seen as indices in the range between zero and the total number of integer partitions, be a nondecreasing sequence. The next section shall expand on the discussion of avoiding permutations of rows in semi-magic squares.
\addtocounter{enumi}{1}
\item Even though the current size is normally set to zero on a very first call to Listing~\ref{allSquaresRecursive}, the backtracking nature of the algorithm will push onto the call stack many other calls to Listing~\ref{allSquaresRecursive} where the current sum scratch memory might have been previously used, thus containing left-over data. Line 9 then checks if the current size is zero, and line 10 sets all entries in the current sum scratch space to zero, to clear any left-over data. If, on the other hand, the current size is greater than zero, then line 12 sets the start of the iteration to the very last index into the integer partition rows seen so far, guaranteeing that the sequence of indices in each square is nondecreasing.
\addtocounter{enumi}{4}
\item Line 14 begins iteration from the last index already in the square. In line 15, the variable \emph{p} stores the memory location of the integer partition row at the current index of iteration, and line 16 utilizes Listing~\ref{plus} to add this integer partition row to the current sum scratch memory.
\addtocounter{enumi}{3}
\item Line 18 calls Listing~\ref{validate} to validate the current sum and, if the sum is valid, line 19 sets the next index in the current square scratch memory, here represented by the variable \emph{tmp}, to the current iteration index and increases the current size. Line 20 then pushes another call to Listing~\ref{allSquaresRecursive} onto the stack, and line 21 backtracks the current size.
\addtocounter{enumi}{5}
\item Regardless whether the validation test in line 18 succeeded, the current sum must be backtracked inside the same block where Listing~\ref{plus} was called. Line 24 accomplishes that with a balancing call to Listing~\ref{minus}.
\end{enumerate}

%--------------------------------------------------------------------------
\section{Computing all possible combination matrices for a row}

%--------------------------------------------------------------------------
This section outlines a procedure that produces all combination matrices of self-derivation of a certain size for a particular row. The main idea relies on departing from a top row, which is a concatenation of transforms of the canonical form of a row $r$. If the row size is $n$, and the problem size is $m$, then the size of the top row is $m \times n$. In terms of derivation theory, the top row is completely linearized, and each of its $m$ transforms of the row $r$ will constitute a column of the combination matrix, if a solution for the top exists. The top itself is not part of the combination matrix, but rather the linearization thereof. It is, nonetheless, the point of departure for the main algorithm in this implementation. The combination matrix per se consists of a semi-magic square of size $m \times m$, where each column in the square defines a partition of the transform of $r$ for the corresponding section of the top. The last component in this view of a combination matrix of self-derivation are the transforms of the row $r$ that can be derived from the top row as a whole from the integer partitions given by the rows of the semi-magic square. These derived rows are a column vector of size $m$ which are called the sides of the combination matrix.

%--------------------------------------------------------------------------
\begin{example}
Let $S = \{ 3, 8, 1, 0, 9, 6, 4, 7, 10, 5, 2, 11 \}$ as in Ex.~\ref{topSquareSideExample} and consider the combination matrix of self-derivation in Eq.~\ref{topSquareSideEquation}. In it, the top vector is $[T_7(S) | RT_2I(S)]$, the side vector is $[S | T_9I(S)]^T$, and the semi-magic square is

	\begin{equation}
        \left[
        \begin{array}{c|c}
            6 & 6 \\
            \hline
            6 & 6
        \end{array}
        \right] \enspace.
    \end{equation}
    
\noindent The row $S$ is not in its canonical form. An application of Listing~\ref{getCanonicalForm} reveals that the canonical form of $S$ is in fact the row $r = \{0, 3, 6, 11, 8, 5, 7, 10, 1, 2, 9, 4\}$, so that $S = RT_{11}(r)$.
\end{example}

%--------------------------------------------------------------------------
\begin{theorem}
	\label{topSquareSideTheorem}
	Let $r$ be a row. If a solution exists for a combination of top, side and square, then it is unique.
	\begin{proof}
	Suppose there exist two different solutions for the same combination of top, side and square. Then each solution comprises a combination matrix of self-derivation, say $M_1$ and $M_2$. By assumption $M_1 \ne M_2$. Now consider the first row of $M_1$, which is a transform of $r$ under $G = D_{2n} \times \mathbb{F}_2$, say $g_1(r)$, where $g_1 \in G$. Since $M_1$ is a solution, when $g_1(r)$ is partitioned using the partition scheme given by the first row of the square, each partition of $g_1(r)$ fits exactly under each column of the top. Each column of the top is totally ordered, and so is each partition of $g_1(r)$. So there is only one way in which one can fit under another. The same reasoning applies to the first row of $M_2$, and to all subsequent rows of $M_1$ and $M_2$. Hence it must be that $M_1 = M_2$ and the solution is unique, as desired.
	\end{proof}
\end{theorem}

%--------------------------------------------------------------------------
\begin{corollary}
	\label{topSquareSideCorollary}
	Let $r$ be a row and let $M$ be a combination matrix corresponding to a top, side and square that together constitute a solution. Then a permutation of the rows of $M$ is also a solution. Moreover, the set of permutations of the rows of $M$ is an equivalence class of solutions.
	\begin{proof}
	By the proof of Th.~\ref{topSquareSideTheorem}, each row of $M$ is a transform of $r$ that fits uniquely under the top following the partition scheme given by the corresponding square row. Because this alignment is unique, the rows of $M$ can be pulled from the top in any order to form different solutions. This proves the first claim. Let $m$ be the problem size and regard the rows of $M$ as a sequence $\mathcal{S}$ of indices from 1 to $m$. Then a permutation of $\mathcal{S}$ can be construed as the action of $S_m$ on itself by left multiplication. Since this action is transitive, the second claim follows.
	\end{proof}
\end{corollary}

%--------------------------------------------------------------------------
\begin{corollary}
	\label{topSquareSideOrbit}
	Let $r$ be a row and let $G = D_{2n} \times \mathbb{F}_2$. If a solution exists for a combination of top, side and square, then the set of $G$-transforms of the solution, where the retrograde operator reverses the entire solution, forms an equivalence class of solutions. In particular, this equivalence class preserves the alignment between the top and the derived rows, up to retrogrades.
    \begin{proof}
    Every top entry is a transform of $r$, say $g_i(r)$, and similarly every side vector entry is also a transform of $r$, say $g_j(r)$, where $m$ is the problem size, $1 \le i, j \le m$ and $g_i, g_j \in G$. The action of $g \in D_{2n}$ by left multiplication on the entire solution is still a solution because, by assumption, every $g_j(r)$ fits uniquely under every $g_i(r)$ following the partition scheme given by the corresponding square row. Since the action of $g$ permutes the order constraints in every $g_i(r)$ and every $g_j(r)$, it follows $g \cdot g_j(r)$ fits uniquely under $g \cdot g_i(r)$ for every $i$ and $j$. If $g \in D_{2n} \times \mathbb{F}_2$ contains the retrograde, the entire solution is reversed. The uniqueness of the alignments is then given by the fact that, for any order constraint $\{a, b\}$ in any transform of $r$, the retrograde of such transform will contain instead the reversed order constraint $\{b, a\}$, as all transforms of $r$ are totally ordered. Because $G$ acts on itself by left multiplication on every $g_i$ and every $g_j$, this is an equivalence relation that preserves the semi-magic square, hence the original alignments, up to reversing the entire solution, as claimed.
    \end{proof}
\end{corollary}

%--------------------------------------------------------------------------
\begin{example}
	Let $r = \{0, 1, 3, 2, 4\}$ be a row, let
	\begin{equation}
		\mathcal{T} = [T_0(r), T_4(r), T_4(r)] = [\{0, 1, 3, 2, 4\}, \{4, 0, 2, 1, 3\}, \{4, 0, 2, 1, 3\}]
	\end{equation}
	be a top vector, let
	\begin{equation}
		S = [T_2I(r), RT_1(r), RT_0(r)]^T = [\{2, 1, 4, 0, 3\}, \{1, 4, 0, 3, 2\}, \{0, 3, 4, 2, 1\}]^T
	\end{equation}
	be a side vector, and consider the semi-magic square
	\begin{equation}
		Q = \left[
    	\begin{array}{c|c|c}
		1 & 1 & 3 \\
		\hline
		1 & 3 & 1 \\
		\hline
		3 & 1 & 1
		\end{array}
    	\right] \enspace.
	\end{equation}
	Then the combination matrix $\mathcal{S}$ is a solution for $T$, $S$ and $Q$.
	\begin{equation}
    	\mathcal{S} = \left[
    	\begin{array}{ccccc|ccccc|ccccc}
        	0 & 1 & 3 & 2 & 4 & 4 & 0 & 2 & 1 & 3 & 4 & 0 & 2 & 1 & 3 \\
        	\hline
        	&&& 2 &&&&& 1 && 4 & 0 &&& 3 \\
        	& 1 &&&& 4 & 0 &&& 3 &&& 2 && \\
        	0 && 3 && 4 &&& 2 &&&&&& 1 &
    	\end{array}
    	\right] \enspace.
	\end{equation}
	The derived rows of $\mathcal{S}$ may be represented as totally ordered sets of totally ordered sets, which are formed by partitioning each side vector entry using the partition scheme provided by the corresponding semi-magic square row. For each tuple $(S_i \; Q_i)$ of side vector entry and semi-magic square row in $\mathcal{S}$, the following set of sets representation is obtained:
	\begin{equation}
	\begin{split}
	(S_1 \; Q_1) &= (\{2, 1, 4, 0, 3\} \; \{1, 1, 3\}) \iff \{\{2\}, \{1\}, \{4, 0, 3\}\} \\
	(S_2 \; Q_2) &= (\{1, 4, 0, 3, 2\} \; \{1, 3, 1\}) \iff \{\{1\}, \{4, 0, 3\}, \{2\}\} \\
	(S_3 \; Q_3) &= (\{0, 3, 4, 2, 1\} \; \{3, 1, 1\}) \iff \{\{0, 3, 4\}, \{2\}, \{1\}\}
	\end{split} \enspace .
	\end{equation}
	The first top vector entry is the row $\{0, 1, 3, 2, 4\}$, and the first entry in the first row of $\mathcal{S}$ is the totally ordered set $\{2\}$. Since a row is a totally ordered set with no repeated entries, there is only one way in which $\{2\}$ can be aligned under $\{0, 1, 3, 2, 4\}$. The same applies to all other entries in every derived row of $\mathcal{S}$. This demonstrates the uniqueness stated in the Th.~\ref{topSquareSideTheorem}. Now consider the permutation of the derived rows of $\mathcal{S}$ given by $\tilde{\mathcal{S}}$.
	\begin{equation}
    	\tilde{\mathcal{S}} = \left[
    	\begin{array}{ccccc|ccccc|ccccc}
        	0 & 1 & 3 & 2 & 4 & 4 & 0 & 2 & 1 & 3 & 4 & 0 & 2 & 1 & 3 \\
        	\hline
        	&&& 2 &&&&& 1 && 4 & 0 &&& 3 \\
        	0 && 3 && 4 &&& 2 &&&&&& 1 & \\
        	& 1 &&&& 4 & 0 &&& 3 &&& 2 &&
    	\end{array}
    	\right] \enspace.
	\end{equation}
	Since a derived combination matrix row is a tuple of side vector entry and a semi-magic square row, permuting the derived rows of a combination matrix preserves the alignments with the top. Since $\mathcal{S}$ is a solution, there are no vertical alignments between its derived rows, so permuting them also preserves the ability to recover the top when collapsing, or linearizing the derived rows. Even though in a solution two side vector entries can be equal, and similarly two semi-magic square rows can also be equal, no two derived rows of a combination matrix can be equal, otherwise there would be vertical alignments, which are impossible in a solution. Therefore each side-square row tuple in a solution must be unique, and thus the number of different solutions obtained by permuting the derived rows of a combination matrix is just the size of the symmetric group $S_m$, where $m$ is the problem size. This demonstrates Cor.~\ref{topSquareSideCorollary}, but it is important to point out that the top vector stays the same in these permutations. Finally, consider the retrograde transform of $\mathcal{S}$.
	\begin{equation}
    	R(\mathcal{S}) = \left[
    	\begin{array}{ccccc|ccccc|ccccc}
        	3 & 1 & 2 & 0 & 4 & 3 & 1 & 2 & 0 & 4 & 4 & 2 & 3 & 1 & 0 \\
        	\hline
        	3 &&& 0 & 4 && 1 &&&&& 2 &&& \\
        	&& 2 &&& 3 &&& 0 & 4 &&&& 1 & \\
        	& 1 &&&&&& 2 &&& 4 && 3 && 0
    	\end{array}
    	\right] \enspace.
	\end{equation}
	The reverse of a solution is still a solution as long as the retrograde operator is applied not only to every entry in the top and side vectors, each being a transform of $r$, but also to the top and side vectors themselves, as well as to every row of the semi-magic square. The reversed top then becomes:
	\begin{equation}
		R(\mathcal{T}) = [RT_4(r), RT_4(r), RT_0(r)] = [\{3, 1, 2, 0, 4\}, \{3, 1, 2, 0, 4\}, \{4, 2, 3, 1, 0\}] \enspace .
	\end{equation}
	Similarly, the set of sets representation of $R(\mathcal{S})$ becomes:
	\begin{equation}
	\begin{split}
	(\{3, 0, 4, 1, 2\} \; \{3, 1, 1\}) &\iff \{\{3, 0, 4\}, \{1\}, \{2\}\} \\
	(\{2, 3, 0, 4, 1\} \; \{1, 3, 1\}) &\iff \{\{2\}, \{3, 0, 4\}, \{1\}\} \\
	(\{1, 2, 4, 3, 0\} \; \{1, 1, 3\}) &\iff \{\{1\}, \{2\}, \{4, 3, 0\}\}
	\end{split} \enspace .
	\end{equation}
	The entire solution $\mathcal{S}$ can also be transformed by an element of $G = D_{2n} \times \mathbb{F}_2$. If $g \in G$ includes the retrograde then, in addition to applying $g$ to all entries in the top and side vectors, top, side and square themselves must be reversed, as above. Let $g = T_2I$. In particular, $g = (0 \; 2) \; (3 \; 4)$ when regarded as a permutation. Then
	\begin{equation}
		g(\mathcal{T}) = [T_2I(r), T_1I(r), T_1I(r)] = [\{2, 1, 4, 0, 3\}, \{3, 2, 0, 1, 4\}, \{3, 2, 0, 1, 4\}] \enspace .
	\end{equation}
	The action of $g$ on the set of sets representation for $\mathcal{S}$ yields:
	\begin{equation}
	\begin{split}
	(\{0, 1, 3, 2, 4\} \; \{1, 1, 3\}) &\iff \{\{0\}, \{1\}, \{3, 2, 4\}\} \\
	(\{1, 3, 2, 4, 0\} \; \{1, 3, 1\}) &\iff \{\{1\}, \{3, 2, 4\}, \{0\}\} \\
	(\{2, 4, 3, 0, 1\} \; \{3, 1, 1\}) &\iff \{\{2, 4, 3\}, \{0\}, \{1\}\}
	\end{split} \enspace .
	\end{equation}
	Combining the transformed top with the transformed set of sets representation under $g$ produces the combination matrix $g(\mathcal{S})$.
	\begin{equation}
    	g(\mathcal{S}) = \left[
    	\begin{array}{ccccc|ccccc|ccccc}
        	2 & 1 & 4 & 0 & 3 & 3 & 2 & 0 & 1 & 4 & 3 & 2 & 0 & 1 & 4 \\
        	\hline
        	&&& 0 &&&&& 1 && 3 & 2 &&& 4 \\
        	& 1 &&&& 3 & 2 &&& 4 &&& 0 && \\
        	2 && 4 && 3 &&& 0 &&&&&& 1 &
    	\end{array}
    	\right] \enspace.
	\end{equation}
	The first top vector entry of $g(\mathcal{S})$ is the row $g(\{0, 1, 3, 2, 4\})$, and the first entry in the first row of the combination matrix is the totally ordered set $g(\{2\})$. Since the action of $g$ permutes the order constraints in both these totally ordered sets in the exact same way, the original alignments are preserved, or at most retrograded, as above. The same applies to all other entries in every derived combination matrix row of $g(\mathcal{S})$. This demonstrates both claims in Cor.~\ref{topSquareSideOrbit}.
\end{example}

%--------------------------------------------------------------------------
As described above, the side and top vectors are key components in this implementation. Even though the side and the top are both vectors of length equal to the problem size, and they are both vectors of $RT_nI$ transforms of a row, there are some important distinctions between them. The most relevant distinction is that the top vector is used to define the input of a problem, whereas the side vector is used to compute a solution. In derivation theory words, the top vector is the linearization of the combination matrix, and each element in the side vector is a transform of the row $r$ that can be derived from the top. Another fundamental distinction is that the contents of a side are permutable by Corollary~\ref{topSquareSideCorollary}, whereas the contents of the top are usually not. Even though there are permutations of the columns of the top vector that yield equivalent solutions, those are special cases and will be discussed in more detail in the next section. Lastly, like Listing~\ref{allSquaresRecursive}, the algorithm presented in Listing~\ref{allSidesRecursive} below also facilitates the understanding of Listing~\ref{allSolutionsRecursive}, but it is not used in computing combination matrices of self-derivation. The algorithm described in Listing~\ref{allTopsRecursive}, on the other hand, is not only used in this implementation, but also an important subject for future research.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all side vectors of a certain size.},label={allSidesRecursive}]
void allSidesRecursive(number *tmp, number currentSize, number problemSize, range classSize, FILE *file) {
    if (currentSize == problemSize) {
        fwrite(tmp, sizeof(number), problemSize, file);
        return;
    }

    number start = currentSize == 0 ? 0 : tmp[currentSize - 1];

    for (range i = start; i < classSize; ++i) {
        tmp[currentSize++] = i;
        allSidesRecursive(tmp, currentSize, problemSize, classSize, file);
        currentSize--;
    }
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are some pre-allocated scratch memory with size equal to the problem size, the current size of the vector, the problem size itself, the size of the row class, and a pointer to a FILE data structure.
\item Line 2 is the base case of the recursion, and simply checks that the current size of the vector has already reached the problem size. If so, line 3 writes the contents of the scratch memory contiguously to the provided FILE handle and line 4 returns control to the caller.
\addtocounter{enumi}{4}
\item Line 7 is a similar mechanism to that described in line 12 of Listing~\ref{allSquaresRecursive}. Like the latter, its purpose is to avoid permutations of the size vector by forcing them to be nondecreasing sequences of indices into the row class array. It will be shown in Listing~\ref{allSolutionsRecursive} that side vectors can actually be strictly increasing sequences.
\addtocounter{enumi}{1}
\item Line 9 begins iteration from the start index computed in line 7, until the last index possible, which is the size of the row class minus one. Line 10 sets the scratch memory's entry at the current size to the current index of iteration and increases the current size. Line 11 pushes onto the call stack another call to Listing~\ref{allSidesRecursive}, and line 12 backtracks by decreasing the current size, thus ensuring that all nondecreasing sequences of indices in the range from zero to row class size minus one are seen and written to the provided FILE.
\end{enumerate}

%--------------------------------------------------------------------------
In this implementation, tops are pre-computed and saved to a file. This is a two-edged sword, as it increases speed at the expense of risking some potentially prohibitive file sizes. Let $r$ be a row of size $n$, let $c$ be the size of its row class, and let $m$ be a problem size. Then the number of all possible tops is $c^m$, which can be an incredibly large number. If $r$ is a 12-tone row that is not retrograde or retrograde inverse-invariant, then $c = 48$. The number of all possible $4 \times 4$ tops is then $48^4 = 5308416$. For music composition applications, $m = 4$ is a rather small number. A composer may well be interested in combination matrices of sizes up to $n$, hence reducing the number of tops into equivalence classes is of utmost importance. Under the action of $RT_nI$, the number of tops can be reduced substantially, but this reduction is asymptotically irrelevant as row size and problem size grow. In other words, dealing with large $n$ and $m$ can be a very difficult problem. On the bright side, this analysis shows that solutions do exist in abundance, however difficult they may be to compute.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all top vectors of a certain size.},label={allTopsRecursive}]
void allTopsRecursive(number *tmp, number currentSize, number problemSize, range classSize, FILE *file) {
    if (currentSize == problemSize) {
        fwrite(tmp, sizeof(number), problemSize, file);
        return;
    }

    if (currentSize == 0)
        tmp[currentSize++] = 0;

    for (range i = 0; i < classSize; ++i) {
        tmp[currentSize++] = i;
        allTopsRecursive(tmp, currentSize, problemSize, classSize, file);
        currentSize--;
    }
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the memory address of some scratch memory space, pre-allocated with size equal to the problem size, the current size of the top, the problem size, the row class size, and a pointer to a FILE where the tops should be saved.
\item Line 2 handles the base case of the recursion, line 3 writes the contents of the current top to the FILE, and line 4 returns.
\addtocounter{enumi}{4}
\item Line 7 restricts the number of tops that will be computed by enforcing in line 8 that the first element of the top vector be always zero. If the problem size is $m$ and the class size is $c$, then Listing~\ref{allTopsRecursive} effectively computes $c^{m - 1}$ tops. It will be shown in the next section how all equivalence classes of tops under the action of $RT_nI$ can be computed departing from $c^{m - 1}$ elements.
\addtocounter{enumi}{2}
\item In line 10, the for-loop always starts from zero, since from the second element to the last, all possibilities are needed. Lines 11 to 13 describe the same backtracking recursive procedure in other algorithms already discussed above.
\end{enumerate}

%--------------------------------------------------------------------------
Similarly to Listing~\ref{writeAllPartitions}, Listing~\ref{writeAllTops} wraps around Listing~\ref{allTopsRecursive} to save a file in the same location where the the main executable is built, so the details are omitted. Unlike Listing~\ref{writeAllPartitions}, however, the output of Listing~\ref{writeAllTops} can be a very large file. Suppose $r$ is a row of size $n = 12$, its row class has size $c = 48$, and the problem size is $m = 8$. Since a number of type char requires one byte of memory, the output of Listing~\ref{writeAllTops} would be a file of size $c^{m - 1} = 546.75$ Gigabytes.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Writing all tops to a file.},label={writeAllTops}]
void writeAllTops(number problemSize, range classSize) {
    char fileName[32];
    sprintf(fileName, "all_tops_%i_%i.dat", problemSize, classSize);
    FILE *file = fopen(fileName, "wb");

    number *tmp = malloc(problemSize * sizeof(number));
    allTopsRecursive(tmp, 0, problemSize, classSize, file);

    free(tmp);
    fclose(file);
}
\end{lstlisting}

%--------------------------------------------------------------------------
The same applies to Listing~\ref{readAllTops}, whose details are omitted for being similar to Listing~\ref{readAllPartitions} above, including the way Listing~\ref{readAllTops} generates a new file if none has been created already.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Reading all tops from a file.},label={readAllTops}]
number *readAllTops(length *numTops, number problemSize, range classSize) {
    char fileName[32];
    sprintf(fileName, "all_tops_%i_%i.dat", problemSize, classSize);

    number *allTops = readFile(fileName, numTops, problemSize);

    if (allTops == NULL) {
        printf("Writing top combos file...\n");
        writeAllTops(problemSize, classSize);
        allTops = readFile(fileName, numTops, problemSize);
    }

    return allTops;
}
\end{lstlisting}

%--------------------------------------------------------------------------
The main algorithm in this implementation writes to a file the combination matrices of self-derivation computed from a provided set of tops, doing so in a format that is readily usable for music composition. It takes as input a significant amount of pre-computed data which can be shared between several threads of execution, as well many pointers to scratch memory addresses that must be allocated for each thread. Both common and thread-specific data are organized into data structures to reduce the number of parameters necessary for each call. These data structures, as well as the text formatting of the output shall be discussed next. Listing~\ref{threadCommonDataStructure} below defines a data structure where all members are immutable, so is safe to be shared between different threads of execution. Some members are common to a particular row, namely the memory address and size of the row class, the retrograde and retrograde inverse maps' addresses, which will be discussed in the next section, the row size, and whether the row is retrograde or retrograde inverse-invariant. All other members are common to all rows of a particular size $n$, given a problem size $m$. These members are namely the memory address and size of all partitions read from the partitions file, the memory address and size of all tops read from the tops file, and the problem size itself.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Defining a data structure to hold thread-common data.},label={threadCommonDataStructure}]
typedef struct {
    number *rowClass, *rMap, *riMap, *allPartitions, *allTops;
    length numPartitions, numTops;
    range topSize, classSize;
    number problemSize, rowSize, isInvariant;
} common_data;
\end{lstlisting}

%--------------------------------------------------------------------------
Listing~\ref{threadSpecificDataStructure}, on the other hand, describes a data structure that cannot be shared between different threads of execution, as it mostly contains allocated scratch memory space to be used in a call to Listing~\ref{allSolutionsRecursive}, which computes all solutions for a given top. The members are, in order, the scratch memory for the size vector, the current top being used as input, the memory address for a stack of tops that will be needed by Listing~\ref{allSolutionsRecursive}, the current sum of the semi-magic square columns, the scratch memory for the semi-magic square itself, and lastly a variable to store the number of solutions obtained by the top at hand.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Defining a data structure to hold thread-specific data.},label={threadSpecificDataStructure}]
typedef struct {
    number *tmpSide, *currentTop, *tmpTops, *currentSum;
    length *tmpSquare;
    length counter;
} thread_data;
\end{lstlisting}

%--------------------------------------------------------------------------
Listing~\ref{writeRow} is used in Listing~\ref{writeSolution} as a subroutine to write as text an entire solution, line-by-line. The lines in the solution include the top line, as well as one line for each entry in the side vector.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Writing a single row from a combination matrix.},label={writeRow}]
void writeRow(const number *row, number rowSize, range topSize, bool newLine, FILE *file) {
    for (range i = 0; i < topSize; ++i) {
        if (i > 0 && i % rowSize == 0)
            write(file, "| ");

        if (row[i] < 0)
            write(file, "   ");
        else if (row[i] < 10)
            write(file, "%i  ", row[i]);
        else
            write(file, "%i ", row[i]);
    }

    if (newLine)
        write(file, "\n");
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the combination matrix row at hand, which includes the top line. These rows have the same length as the top row. Rows that are derived from the top, however, will have nonnegative entries whenever those entries align with the top's current index, and minus one otherwise. Next, the row size, which is used to add separators at each of the top's columns, the top size, a boolean to indicate whether a new line character should be included after the combination matrix, and the address of a FILE data structure.
\item Line 2 iterates over the top's length and line 3 checks if the current index of iteration has reached the boundary of a column. If so, line 4 writes a separator character and a space.
\addtocounter{enumi}{3}
\item Line 6 checks if the current row's entry is less than zero, in which case there is nothing to align with the top, hence line 7 writes three spaces. Line 8 checks if the current entry is less than ten, in which case line 9 writes a single-character number and two spaces. If line 10 is reached, then the current entry has two characters, so line 11 writes the two-digit number and a single space.
\addtocounter{enumi}{7}
\item Line 14 checks if a new line character was requested and, if so, line 15 writes one to the file.
\end{enumerate}

%--------------------------------------------------------------------------
The algorithm for converting a solution into text is presented below in Listing~\ref{writeSolution}. A text solution consists of the solution number within the thread-specific context, and all the rows appended using calls to Listing~\ref{writeRow}. If a single thread is used, then the solution number is unique within the set of all solutions, otherwise it is only unique within the text file created by the thread that processed the solution. The rows of the combination matrix are prepended by their side vector index, and appended by their square row index, which is an index into the array of all integer partitions of size $n$, with entries in the range $[0, n - 1]$, as previously discussed.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Writing an entire solution.},label={writeSolution}]
void writeSolution(thread_data *d, common_data *cd, FILE *solutionsFile) {
    write(solutionsFile, "Solution %lu:\n\n     ", d->counter);
    writeRow(d->tmpTops, cd->rowSize, cd->topSize, true, solutionsFile);

    for (number i = 0; i < cd->problemSize; ++i) {
        range topIndex = 0;
        number rowIndex = 0;
        const number *p = &cd->allPartitions[d->tmpSquare[i] * cd->problemSize];
        const number *r = &cd->rowClass[d->tmpSide[i] * cd->rowSize];
        memset(d->currentTop, -1, cd->topSize * sizeof(number));

        for (number j = 0; j < cd->problemSize; ++j) {
            number pj = p[j];

            for (range k = topIndex; k < topIndex + cd->rowSize; ++k) {
                if (pj == 0)
                    break;

                if (d->tmpTops[k] == r[rowIndex]) {
                    d->currentTop[k] = r[rowIndex];
                    rowIndex++;
                    pj--;
                }
            }

            topIndex += cd->rowSize;
        }

        if (d->tmpSide[i] < 10)
            write(solutionsFile, "%i  | ", d->tmpSide[i]);
        else
            write(solutionsFile, "%i | ", d->tmpSide[i]);

        writeRow(d->currentTop, cd->rowSize, cd->topSize, false, solutionsFile);
        write(solutionsFile, "| %lu\n", d->tmpSquare[i]);
    }

    write(solutionsFile, "\n");
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the address of a thread-specific data structure, the address of a thread-common structure, and a pointer to a FILE structure.
\item Line 2 writes the solution number within the current thread context. It also writes an additioinal line break and five spaces, since the next line to be written is the top vector, which is not prepended by a side vector entry like the other derived rows. Line 3 then calls Listing~\ref{writeRow} to write the top vector, using the fact that the latter is stored as the bottommost element of the \emph{tmpTops} stack, whose details are deferred until the next section. 
\addtocounter{enumi}{2}
\item Line 5 iterates over the problem size, which is precisely the number of derived rows that combine to form a combination matrix. The thread-specific data structure provided as input contains a schematic solution, given by indices into various arrays found in the thread-common data structure. Therefore each derived row must be constructed before being written. Line 6 is then an index into the top vector, and line 7 is an index into the derived row. Line 8 is the address of the semi-magic square row within all the integer partitions, and line 9 is the address of the derived row within the row class. The memory address used to compute the spelled-out derived row is a reused scratch space, hence it is re-initialized at every iteration of the for-loop in line 5. Line 10 fills this scratch space with minus ones, as negative entries are skipped in Listing~\ref{writeRow}.
\addtocounter{enumi}{6}
\item Line 12 too iterates over the problem size, only this time regarding each column of the semi-magic square. Line 13 simply stores the integer partition value for the current iteration in a variable for convenience. This value is effectively the cell of the semi-magic square at row \emph{i} and column \emph{j}.
\addtocounter{enumi}{2}
\item The innermost for-loop in line 15 starts from the last top index and iterates $n$ times, where $n$ is the row size, and its body is responsible for matching the next \emph{pj} entries in the derived row against the entire \emph{j}\textsuperscript{th} column in the top vector, which has size $n$. Line 16 checks if all \emph{pj} entries have been matched, in which case line 17 breaks the for-loop.
\addtocounter{enumi}{3}
\item Line 19 checks if the derived row's entry at the current row index aligns with the current top column at the index of iteration given in line 15. If so, line 20 updates the scratch memory that will be used to write the derived row, line 21 increments the row index, and line 22 decrements \emph{pj}, which at each iteration represents the number of elements in the current square cell that still need to be matched.
\addtocounter{enumi}{5}
\item Line 25 increments the current top index by $n$ at each iteration of the for-loop in line 12, needed in order to traverse the top vector, column-by-column.
\addtocounter{enumi}{1}
\item Line 27 checks if the current side vector index is less than ten, that is, if it has a single digit and, if so, line 28 prepends to the derived row line the side index, followed by two spaces and a separator. If the side index requires two digits, then line 30 prepends the side index, followed by a single space and a separator.
\addtocounter{enumi}{4}
\item Line 32 calls Listing~\ref{writeRow} to write the computed derived row without a line break. Line 33 then prepends to the line the current square row index and a new line character.
\addtocounter{enumi}{3}
\item Line 36 simply separates this solution from the next with an additional line break.
\end{enumerate}

%--------------------------------------------------------------------------
\begin{example}
	Below is a sample output of Listing~\ref{writeSolution}. In it, the row $r = \{0, 1, 4, 2, 5, 3\}$ is a 6-tone row that is not retrograde or retrograde inverse-invariant. The top row is the vector $\{T_0(r), RT_3I(r), T_0I(r)\}$. The side vector is equal to $\{21, 16, 19\} = \{RT_3I(r), RT_1(r), RT_4(r)\}$. The semi-magic square is the vector $\{8, 13, 17\}$. These are indices into the array of all partitions of six, that can be inferred from the combination matrix to be the square
	
	\begin{equation}
        \left[
        \begin{array}{c|c|c}
            1 & 3 & 2 \\
            \hline
            2 & 2 & 2 \\
            \hline
            3 & 1 & 2
        \end{array}
        \right] \enspace.
    \end{equation}
\end{example}

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize,numbers=none]
Solution 610:

     0  1  4  2  5  3  | 0  4  1  5  2  3  | 0  5  2  4  1  3  
21 | 0                 |    4  1  5        |       2        3  | 8
16 |    1           3  | 0           2     |    5     4        | 13
19 |       4  2  5     |                3  | 0           1     | 17
\end{lstlisting}

\vspace{12pt}

%--------------------------------------------------------------------------
The algorithm presented in Listing~\ref{allSolutionsRecursive} is the main procedure in this implementation for computing solutions to the problem of self-derivation. Like other algorithms described in the previous sections, it is a recursive backtracking algorithm. It utilizes Listing~\ref{matchRowWithTop} as a subroutine to test if the a given representative of a row class can be matched with the top row. Listing~\ref{matchRowWithTop} is very similar to the first inner for-loop in Listing~\ref{writeSolution} in that it tries to match a transform of the row $r$ against a top vector, and that matching is done column-by-column, using the partition scheme given by the current square row. The main difference between Listing~\ref{writeSolution} and Listing~\ref{matchRowWithTop} lies in the fact that the top row is not immutable. Rather, it is some scratch memory space that gets changed every time Listing~\ref{matchRowWithTop} is called. Another key difference is the fact that Listing~\ref{matchRowWithTop} can fail to produce a match, whereas Listing~\ref{writeSolution} is only called once a solution already exists for all derived rows.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Matching a representative of a row class with a given top vector.},label={matchRowWithTop}]
bool matchRowWithTop(number *top, const number *row, const number *partitions, number problemSize, number rowSize) {
    range topIndex = 0;
    number rowIndex = 0;

    for (number i = 0; i < problemSize; ++i) {
        number p = partitions[i];

        for (range j = topIndex; j < topIndex + rowSize; ++j) {
            if (p == 0)
                break;

            if (top[j] == row[rowIndex]) {
                top[j] = -1;
                rowIndex++;
                p--;
            }
        }

        if (p > 0)
            return false;

        topIndex += rowSize;
    }

    return rowIndex == rowSize;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are a memory address that holds some scratch space with size equal to the top size, the address of the transform of the row which the algorithm will try to match with the top, the address of the integer partition to be used, that is, a row from the semi-magic square, the problem size, and the row size.
\item Like lines 6 and 7 in Listing~\ref{writeSolution}, lines 2 and 3 here are indices into the top vector and row transform, respectively.
\addtocounter{enumi}{2}
\item Line 5 iterates over the problem size, that is, over the number of columns in the top vector, similarly to line 12 in Listing~\ref{writeSolution}. Line 6 stores in a variable the current square cell value, and the use of variable \emph{p} here is identical to the use of variable \emph{p} in Listing~\ref{writeSolution}.
\addtocounter{enumi}{2}
\item The inner for-loop in line 8, as well as the check in lines 9 and 10 are identical to lines 15 to 17 in Listing~\ref{writeSolution}.
\addtocounter{enumi}{3}
\item Line 12 tests that the \emph{j}\textsuperscript{th} entry in the top vector matches the row transform at the current row index. Unlike Listing~\ref{writeSolution}, the top vector may not be unaltered. If the \emph{j}\textsuperscript{th} entry in the top vector was already matched to a different transform of the row $r$ in a previous call to Listing~\ref{matchRowWithTop}, then the \emph{j}\textsuperscript{th} entry in the top vector will have been set to minus one, and Listing~\ref{matchRowWithTop} will fail. Otherwise, line 13 will set the \emph{j}\textsuperscript{th} entry in the top vector to minus one, which differs from Listing~\ref{writeSolution} in the sense that the latter sets a scratch memory space that had previously initialized with minus ones to the the corresponding entry in the row transform. Line 14 increases the row index, and line 15 decreases \emph{p}, similarly to what Listing~\ref{writeSolution} does in lines 21 and 22.
\addtocounter{enumi}{6}
\item Line 19 checks that all \emph{p} elements from the row transform starting at the current row index have been matched with the current top vector column. If not, line 20 returns false.
\addtocounter{enumi}{2}
\item If line 22 is reached, then the top index is increased by the row size, like line 25 in Listing~\ref{writeSolution}, and the algorithm moves to the next top vector column.
\addtocounter{enumi}{2}
\item If line 25 is reached, then the row transform has been matched successfully to all top vector columns. Still, the algorithm performs a sanity check and confirms that all row elements have been indeed matched by comparing the current row index with the row size.
\end{enumerate}

%--------------------------------------------------------------------------
Listing~\ref{allSolutionsRecursive} combines Listing~\ref{allSidesRecursive} and Listing~\ref{allSquaresRecursive} to compute all possible solutions for a given top. The general idea is, for each potential row of a semi-magic square, to try to match a transform of the row $r$ with the current top using Listing~\ref{matchRowWithTop}. If that succeeds, Listing~\ref{allSolutionsRecursive} recurses then backtracks, thus covering all of the row class and all of the partitions. Side vectors are not computed directly, but rather as a side effect of matching transforms of $r$ with the top. The side vector is still maintained as the algorithm recurses, as it is crucial for avoiding permutations of the rows, as previously discussed, and is also used in Listing~\ref{writeSolution} to label each derived row in the text output of a solution.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all solutions for a top vector of a certain size.},label={allSolutionsRecursive}]
void allSolutionsRecursive(thread_data *d, common_data *cd, FILE *solutionsFile, number currentSize) {
    if (currentSize == cd->problemSize) {
        d->counter++;
        writeSolution(d, cd, solutionsFile);
        return;
    }

    length start = 0;

    if (currentSize > 0) {
        start = d->tmpSquare[currentSize - 1];
        memcpy(&d->tmpTops[currentSize * cd->topSize], d->currentTop, cd->topSize * sizeof(number));
    }

    for (length i = start; i < cd->numPartitions; ++i) {
        const number *p = &cd->allPartitions[i * cd->problemSize];
        plus(d->currentSum, p, cd->problemSize);

        if (validate(d->currentSum, cd->problemSize, cd->rowSize)) {
            d->tmpSquare[currentSize] = i;
            number rowStart = 0;

            if (currentSize > 0 && start == i)
                rowStart = d->tmpSide[currentSize - 1] + 1;

            for (range j = rowStart; j < cd->classSize; ++j) {
                const number *r = &cd->rowClass[j * cd->rowSize];

                if (matchRowWithTop(d->currentTop, r, p, cd->problemSize, cd->rowSize)) {
                    d->tmpSide[currentSize++] = j;
                    allSolutionsRecursive(d, cd, solutionsFile, currentSize);
                    currentSize--;
                }

                memcpy(d->currentTop, &d->tmpTops[currentSize * cd->topSize], cd->topSize * sizeof(number));
            }
        }

        minus(d->currentSum, p, cd->problemSize);
    }
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the memory address of the thread-specific data, the memory address of the thread-common data, a pointer to a FILE data structure, and the current size of the call stack.
\item Line 2 deals with the base case of the recursion by testing whether the current size has reached the problem size. If so, line 3 increases the thread-specific solution counter, line 4 calls Listing~\ref{writeSolution} to write the solution to the provided FILE, and line 5 returns.
\addtocounter{enumi}{5}
\item Line 8 initializes a variable representing where iteration of integer partition rows should start, similarly to line 7 in Listing~\ref{allSquaresRecursive}.
\addtocounter{enumi}{1}
\item Line 10 tests if the current size is greater than zero and, if so, line 11 sets the start value to the last row appended to the current semi-magic square, similarly to what line 12 in Listing~\ref{allSquaresRecursive} does, and line 12 here pushes onto the top history stack the current top. As derived rows are added to form a solution, the state of the current sum of square columns is always easy to backtrack by subtracting from the current sum array the last integer partition row that was appended to the square. Backtracking the current top, on the other hand, is more difficult. Every time a derived row is successfully matched against the current top, the entries where they align according to the square row at hand will be set to minus one in the current top. If all derived rows are matched and a solution is found, the entire current top scratch memory will contain only minus ones. Therefore backtracking the current top requires maintaining its history every time Listing~\ref{matchRowWithTop} succeeds and a new call to Listing~\ref{allSolutionsRecursive} is pushed onto the call stack.
\addtocounter{enumi}{4}
\item Lines 15 to 17 do exactly what lines 14 to 16 do in Listing~\ref{allSquaresRecursive}.
\addtocounter{enumi}{3}
\item Similarly, lines 19 and 20 are identical to lines 18 and 19 in Listing~\ref{allSquaresRecursive}. At this point, the current sum of square columns has been validated and a new integer partition row has been appended to the square. With an integer partition row and a current top in place, the algorithm now searches for a representative of the row class that will fit under the current top given the scheme provided by the integer partition. Line 21 then declares a variable to represent what the start index of iteration over the representatives of the row class should be.
\addtocounter{enumi}{3}
\item The rows of the square, seen as indices into the array of all integer partition rows, form a nondecreasing sequence. That is to avoid permutations of the square's rows, as by Cor.~\ref{topSquareSideCorollary} two squares with permuted rows are equivalent. Nonetheless, squares may have several repeated rows. One simple example is the square in which all entries are equal to $n / m$, where $n$ is the row size, $m$ is the problem size, and $m$ divides $n$. Line 23 tests for the case where the current square row is the same as the previous one, which can only be true if the current size is greater than zero. If that is the case, then the sequence of representatives of the row class that fall under the subsequence of repeated integer partition rows can be allowed to be nondecreasing, as well, to avoid permutations that would produce equivalent solutions. In fact, a stronger condition applies, and the sequence of representatives falling under repeated square rows can be strictly increasing. That is because the same representative of a row class cannot fit under the top row twice using the same integer partition row scheme. Line 24 then changes the start index of iteration over the representatives of the row class accordingly.
\addtocounter{enumi}{2}
\item Line 26 iterates over the representatives of a row class, according to the row start index declared in line 21, and line 27 stores in a variable the memory address of the representative being considered.
\addtocounter{enumi}{2}
\item Line 29 is a call to Listing~\ref{matchRowWithTop}. If it succeeds, line 30 sets the next row representative index in the side vector and increases the current size. Line 31 then pushes another call to Listing~\ref{allSolutionsRecursive} onto the stack, and line 32 backtracks the current size.
\addtocounter{enumi}{5}
\item Line 35 backtracks the current top to its previous state, using the top history stored in the top history stack in line 12. Every call to Listing~\ref{matchRowWithTop} is matched with the backtracking procedure in line 35.
\addtocounter{enumi}{3}
\item Finally, line 39 backtracks the current sum of square columns with a balancing call to Listing~\ref{minus}, similarly to what Listing~\ref{allSquaresRecursive} does in its line 24.
\end{enumerate}

%--------------------------------------------------------------------------
\section{Creating work data for use in concurrent threads}

%--------------------------------------------------------------------------
This section outlines the procedures used for allocating the data structures to be used as inputs to Listing~\ref{allSolutionsRecursive}. Pre-allocating and reusing scratch memory locations is absolutely critical for the performance of all algorithms described above. Unnecessary calls to allocate and deallocate memory can significantly increase the time it takes for Listing~\ref{allSolutionsRecursive} to execute as row size and problem size grow. Listing~\ref{createCommonData} describes how thread-common data is allocated, and every call to Listing~\ref{createCommonData} should be balanced with a call to Listing~\ref{destroyCommonData} when resources are no longer needed. Listing~\ref{createCommonData} allocates two arrays with size equal to the row class size. These are namely the retrograde and the retrograde inverse maps. As the names suggest, these are mappings between indices within the row class. The retrograde map takes an element into its retrograde, and the retrograde inverse map takes an element into its retrograde inverse. These maps will be used in conjunction with Listing~\ref{unseen}, thus further details are deferred until the next section.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Allocating thread-common data.},label={createCommonData}]
void createCommonData(common_data *cd, int argc, char *argv[]) {
    number problemSize = (number) strtol(argv[1], NULL, 10);
    number rowSize = argc - 2;
    number *row = malloc(rowSize * sizeof(number));

    for (number i = 0; i < rowSize; ++i)
        row[i] = (number) strtol(argv[i + 2], NULL, 10);

    cd->problemSize = problemSize;
    cd->rowSize = rowSize;
    cd->topSize = problemSize * rowSize;

    bool rInvariant = isRetrogradeInvariant(row, rowSize);
    bool riInvariant = isRetrogradeInverseInvariant(row, rowSize);

    cd->isInvariant = rInvariant || riInvariant;
    cd->rowClass = getRowClass(&cd->classSize, row, rowSize, cd->isInvariant);
    cd->rMap = malloc(cd->classSize * sizeof(number));
    cd->riMap = malloc(cd->classSize * sizeof(number));
    cd->allPartitions = readAllPartitions(&cd->numPartitions, problemSize, rowSize);
    cd->allTops = readAllTops(&cd->numTops, problemSize, cd->classSize);

    if (rInvariant) {
        for (int i = 0; i < rowSize; ++i)
            cd->rMap[i] = cd->rowClass[(i + 1) * rowSize - 1];

        for (int i = rowSize; i < cd->classSize; ++i)
            cd->rMap[i] = cd->rowClass[(i + 1) * rowSize - 1] + rowSize;
    } else {
        for (int i = 0; i < rowSize; ++i)
            cd->rMap[i] = cd->rowClass[(i + 1) * rowSize - 1] + rowSize;

        for (int i = rowSize; i < cd->classSize; ++i)
            cd->rMap[i] = cd->rowClass[(i + 1) * rowSize - 1];
    }

    for (int i = 0; i < cd->classSize; ++i)
        cd->riMap[i] = (cd->rMap[i] == 0 || cd->rMap[i] == rowSize)
                       ? modulo(cd->rMap[i] + rowSize, cd->classSize)
                       : modulo(-cd->rMap[i], cd->classSize);

    free(row);
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the memory address of a thread-common data structure, the number of arguments provided in the command line, and the array of such arguments. Listing~\ref{createCommonData} allocates the internal pointers in a thread-common data structure, but also parses the command line inputs, which are a problem size and a row, separated by spaces. The row does not need to be in its canonical form.
\item Line 2 retrieves the problem size from the first element in the arguments array. Note that the zeroth element is the application name. Line 3 then computes the row size, which is just the number of arguments minus two, namely the row size and the application name. Line 4 allocates some memory space which will be used to parse the row provided in the remaining arguments.
\addtocounter{enumi}{3}
\item Line 6 iterates through the row size and line 7 parses each row entry provided, storing them in the memory allocated in line 4.
\addtocounter{enumi}{2}
\item Line 9 updates the provided pointer to a thread-common data structure with the problem size, line 10 updates the row size, and line 11 computes and updates the top size.
\addtocounter{enumi}{3}
\item Line 13 is a call to Listing~\ref{isRetrogradeInvariant} to determine if the row is retrograde-invariant, and line 14 is similarly a call to Listing~\ref{isRetrogradeInverseInvariant} to determine if the row is retrograde inverse-invariant. Note that the row does not need to be in its canonical form when determining retrograde or retrograde inverse invariance.
\addtocounter{enumi}{2}
\item Line 16 updates the data pointer with information whether the row is retrograde or retrograde inverse-invariant. The specific information whether retrograde invariance occurs under inversion or not will be needed to compute retrograde and retrograde inverse maps in Listing~\ref{createCommonData}, but will not be needed in the algorithms that depend on a thread-common data structure. Line 17 is a call to Listing~\ref{getRowClass}, which allocates and returns the memory address of the row class array. Line 18 allocates the memory that will hold the retrograde map, and line 19 allocates the memory that will hold the retrograde inverse map. Lines 20 and 21 are calls to respectively Listing~\ref{readAllPartitions} and Listing~\ref{readAllTops}, both returning allocated memory addresses.
\addtocounter{enumi}{6}
\item Line 23 tests if the row is retrograde-invariant and, if so, line 24 iterates over the size of the row, filling the first half of the retrograde map in line 25. Note that, since the row is retrograde-invariant, the size of the row class is twice the size of the row.
\addtocounter{enumi}{3}
\item Line 27 continues iterating over the class size, filling the second half of the retrograde map in line 28.
\addtocounter{enumi}{2}
\item If the row is retrograde inverse-invariant, line 30 iterates over the size of the row, filling the first half of the retrograde map in line 31. Note that here the first and second halves of the retrograde map are reversed in regard to the retrograde-invariant case, that is, line 31 does the same computation that line 28 does.
\addtocounter{enumi}{2}
\item Line 33 continues iterating over the class size, filling the second half of the retrograde map in line 34, with the same computation in line 25.
\addtocounter{enumi}{3}
\item Line 37 iterates over the entire size of the row class to set the values in the retrograde inverse map. Line 38 tests if the corresponding retrograde map entry contains the $T_0$ or the $T_0I$ transforms of the row, in which case line 39 assigns these indices such that $T_0 \mapsto T_0I$ and $T_0I \mapsto T_0$. If not, then line 40 assigns the other indices such that $T_x \mapsto T_{-x}$.
\addtocounter{enumi}{4}
\item Finally, line 42 deallocates the space created in line 4, as the original row can now be retrieved from the row class array.
\end{enumerate}

%--------------------------------------------------------------------------
\begin{example}
\label{rMapExample}
Let $r$ be a retrograde-invariant row with size $n = 6$. Then the row class array computed by Listing~\ref{getRowClass} will contain a sequence of transforms of $r$ equal to $C = \{T_0, \cdots, T_5, T_0I, \cdots, T_5I\}$. The retrograde map of the row class of $r$ will be the sequence containing the last entry in each transform of $r$ in $C$. This sequence will always be equal to $C_R = \{3, 4, 5, 0, 1, 2, 9, 10, 11, 6, 7, 8\}$. Since $r$ is retrograde-invariant, the sequence $\{0, \cdots, 5\}$ of indices of $r$ maps to itself under the retrograde operator, that is, $R$ is the permutation $(0 \; 5) \; (1 \; 4) \; (2 \; 3)$ when seen as a permutation of indices. Since $r = RT_x(r)$ by assumption, $Tx$ must be a transposition that, seen as a permutation of pitch-classes, comprises solely 2-cycles. This is only possible if $x = 3$. Since $T_3 = (0 \; 3) \; (1 \; 4) \; (2 \; 5)$, the array given by $C_R$, when seen as a permutation of indices of the row class, is in fact the map
\begin{equation}
	T_0 \mapsto T_3, \cdots, T_5 \mapsto T_2, T_3I \mapsto T_0I, \cdots, T_5I \mapsto T_2I \enspace.
\end{equation}
Given an index in $C$, the retrograde map takes that index to another index in $C$ such that a transform of $r$ maps to itself under $RT_\frac{n}{2}$. Let $C_I = \{6, 11, 10, 9, 8, 7, 0, 5, 4, 3, 2, 1\}$ be the array that maps a transform of $r$ in the row class array to its inverse. Seen as a permutation, $C_I = (0 \; 6) \; (1 \; 11) \; (2 \; 10) \; (3 \; 9) \; (4 \; 8) \; (5 \; 7)$. The retrograde inverse map is then the composition of $C_R$ with $C_I$, that is
\begin{equation}
	C_R \circ C_I = \{9, 8, 7, 6, 11, 10, 3, 2, 1, 0, 5, 4\} \enspace.
\end{equation}
\end{example}

%--------------------------------------------------------------------------
\begin{example}
Let $r = \{0, 2, 3, 4, 5, 1\}$, with $n$, $C$ and $C_I$ as in Ex.~\ref{rMapExample}. Then $r$ is retrograde inverse-invariant. The sequence containing the last entry in each transform of $r$ in $C$ will depend on which $x$ satisfies $r = RT_xI(r)$. Since $T_xI$, seen as a permutation, must comprise only 2-cycles, $x$ is necessarily odd. In particular, $x = 1$ for this choice of $r$, but unlike retrograde maps, retrograde inverse maps depend on the row at hand. More precisely, on the transposition index in the operation that maps the row to itself. Here, $C_R = \{7, 8, 9, 10, 11, 6, 5, 0, 1, 2, 3, 4\}$ and thus
\begin{equation}
	C_R \circ C_I = \{5, 4, 3, 2, 1, 0, 7, 6, 11, 10, 9, 8\} \enspace.
\end{equation}
\end{example}

%--------------------------------------------------------------------------
Listing~\ref{destroyCommonData} below describes how the data allocated in Listing~\ref{createCommonData} is deallocated. It simply frees all the memory that had been previously allocated in the heap. Due to their simplicity, further details are omitted in the next three routines.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Deallocating thread-common data.},label={destroyCommonData}]
void destroyCommonData(common_data *cd) {
    free(cd->rowClass);
    free(cd->rMap);
    free(cd->riMap);
    free(cd->allPartitions);
    free(cd->allTops);
}
\end{lstlisting}

%--------------------------------------------------------------------------
Listing~\ref{createThreadData} is a very simple procedure, as well. As it depends on a previous call to Listing~\ref{createCommonData}, all thread-common data has already been allocated, and sizes computed. Listing~\ref{createThreadData} then allocates the necessary scratch areas that cannot be shared between different thread contexts, and sets the thread-specific solution counter to zero.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Allocating thread-specific data.},label={createThreadData}]
void createThreadData(thread_data *d, common_data *cd) {
    d->counter = 0;
    d->tmpSide = malloc(cd->problemSize * sizeof(number));
    d->currentTop = malloc(cd->topSize * sizeof(number));
    d->tmpTops = malloc(cd->problemSize * cd->topSize * sizeof(number));
    d->currentSum = malloc(cd->problemSize * sizeof(number));
    d->tmpSquare = malloc(cd->problemSize * sizeof(length));
}
\end{lstlisting}

%--------------------------------------------------------------------------
Similarly to Listing~\ref{destroyCommonData}, Listing~\ref{destroyThreadData} deallocates the heap memory that was allocated in Listing~\ref{createThreadData}. Here too, every call to Listing~\ref{createThreadData} should be balanced with a call to Listing~\ref{destroyThreadData} when resources are no longer needed.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Deallocating thread-specific data.},label={destroyThreadData}]
void destroyThreadData(thread_data *d) {
    free(d->tmpSide);
    free(d->currentTop);
    free(d->tmpTops);
    free(d->currentSum);
    free(d->tmpSquare);
}
\end{lstlisting}

%--------------------------------------------------------------------------
\section{Computing all possible solutions for a row class}

%--------------------------------------------------------------------------
This section outlines Listing~\ref{writeSolutions}, a procedure that wraps Listing~\ref{allSolutionsRecursive}, providing it with the necessary scaffolding to output all solutions computed to a text file. In a single-threaded context, Listing~\ref{writeSolutions} will be furnished with all possible tops for a given problem size. In a multi-threaded context, however, Listing~\ref{writeSolutions} will be given a range of tops to be processed by each thread. Listing~\ref{allTopsRecursive} above computes the minimal subset of tops necessary for the operation of Listing~\ref{writeSolutions}. As previously discussed, the number of possible tops becomes impractically large as the problem size grows. Many algorithms described in this section deal with skipping tops that can be achieved by retrograding a top that has already been seen. Listing~\ref{writeSolutions} itself handles computing tops that cannot be achieved from the results of Listing~\ref{allTopsRecursive}. Listing~\ref{createSolutionsFile} creates a file to which solutions will be written.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Creating a text file to hold all thread-specific solutions.},label={createSolutionsFile}]
FILE *createSolutionsFile(number *row, number problemSize, number rowSize, length startTop, length endTop) {
    char fileName[64];
    sprintf(fileName, "all_solutions_%i", problemSize);
    char offset = problemSize < 10 ? 15 : 16;

    for (number i = 0; i < rowSize; ++i) {
        sprintf(&fileName[offset], "_%i", row[i]);
        offset += row[i] < 10 ? 2 : 3;
    }

    sprintf(&fileName[offset], "_%lu_%lu.txt", startTop, endTop);

    return fopen(fileName, "wt");
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the row in canonical form, the problem size, the row size, and the start and end indices into the all-tops array. Since this file will contain solutions only for the tops between theses indices, the indices are used in the name of the file, to distinguish it from other files written by other threads.
\item Line 2 creates a buffer to store the file name, and line 3 writes the first part of the name into the buffer. Line 4 computes the current offset from which the rest of the name should start, which depends on the problem size.
\addtocounter{enumi}{3}
\item Line 6 iterates over the row size, appending in line 7 each row entry to the file name, and updating in line 8 the offset declared in line 4.
\addtocounter{enumi}{4}
\item Line 11 appends to the file name the start and end top indices.
\addtocounter{enumi}{1}
\item Line 13 returns a pointer to a FILE.
\end{enumerate}

%--------------------------------------------------------------------------
The procedure for determining whether a top can be achieved from a previously processed top by some $RT_nI$ transform differs if the row is retrograde or retrograde inverse-invariant or not. Listing~\ref{unseen} outlines the procedure for retrograde or retrograde inverse-invariant rows, whereas Listing~\ref{seen} outlines the procedure for rows otherwise. The next three algorithms below are used as subroutines in Listing~\ref{seen}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Computing the index of the inverse row within a row class.},label={getInverse}]
range getInverse(range num, number rowSize) {
    if (num == 0 || num == rowSize * 2)
        return num + rowSize;

    if (num == rowSize || num == rowSize * 3)
        return num - rowSize;

    if (num < rowSize * 2)
        return rowSize * 2 - num;

    return rowSize * 6 - num;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the index of the row within the row class, and the row size.
\item Line 2 tests if the given transform is either $T_0$ or $RT_0$, in which case line 3 returns respectively $T_0I$ or $RT_0I$.
\addtocounter{enumi}{2}
\item Line 5 does the opposite of line 2, that is, it tests if the given transform is either $T_0I$ or $RT_0I$, in which case line 6 returns respectively $T_0$ or $RT_0$.
\addtocounter{enumi}{2}
\item Line 8 tests if the given transform is not retrograded, in which case line 9 returns an index within the first half of the row class size.
\addtocounter{enumi}{2}
\item If line 11 is reached, then the given transform is retrograded, so the the index returned lies within the second half of the row class size.
\end{enumerate}

%--------------------------------------------------------------------------
Listing~\ref{getReverse} is a lot simpler than Listing~\ref{getInverse}. It simply takes an index in the first half of the row class size and returns the corresponding index in the second half, and vice-versa.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Computing the index of the retrograde row within a row class.},label={getReverse}]
range getReverse(range num, number rowSize) {
    return (num + rowSize * 2) % (rowSize * 4);
}
\end{lstlisting}

%--------------------------------------------------------------------------
Listing~\ref{getReverseInverse} is even simpler and just combines calls to Listing~\ref{getInverse} and Listing~\ref{getReverse} to return the retrograde inverse index of the provided input index.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Computing the index of the retrograde inverse row within a row class.},label={getReverseInverse}]
range getReverseInverse(range num, number rowSize) {
    return getInverse(getReverse(num, rowSize), rowSize);
}
\end{lstlisting}

%--------------------------------------------------------------------------
Listing~\ref{seen} is designed to filter tops that can be achieved by transforming some previously seen top. It relies on the order in which Listing~\ref{allTopsRecursive} outputs tops to filter out top invariances under the retrograde operation.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a top has already been seen.},label={seen}]
bool seen(const number *combo, common_data *cd) {
    number last = cd->problemSize - 1;
    bool I = (combo[last] % (cd->rowSize * 2)) > (cd->rowSize - 1);
    number T = combo[last] % cd->rowSize;
    range back, transform, offset;

    for (int i = 0; i <= last; ++i) {
        if (I) {
            back = getReverseInverse(combo[last - i], cd->rowSize);
            transform = modulo(back + T, cd->rowSize);
        } else {
            back = getReverse(combo[last - i], cd->rowSize);
            transform = modulo(back - T, cd->rowSize);
        }

        offset = (back / cd->rowSize) * cd->rowSize;

        if (combo[i] < transform + offset)
            return false;
        else if (combo[i] > transform + offset)
            return true;
    }

    return false;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the memory addresses of a top row and of a thread-common data structure. The output is a boolean representing whether the top has already been seen.
\item Line 2 stores in a variable the index of the last row in the top. Line 3 determines if the last top entry is inverted, that is, if it lies in the second or fourth quarters of the row class size. Line 4 determines the last top entry's index of transposition. Line 5 declares three variables that will be needed in the for-loop in line 7.
\addtocounter{enumi}{4}
\item Line 7 iterates through all entries in the top, retrograding or retrograde-inverting it. Line 8 checks if the top is inverted, and if so, line 9 calls Listing~\ref{getReverseInverse} and stores the result. Line 10 uses the index of transposition computed in line 4 to determine the transposition index of the top entry at hand, modulo the row size.
\addtocounter{enumi}{4}
\item Line 12 is the equivalent to line 9 when the top is not inverted, that is, it stores the result of a call to Listing~\ref{getReverse}. Line 13 is similarly the equivalent to line 10, and accordingly subtracts modulo the row size the value computed in line 4 instead of adding.
\addtocounter{enumi}{3}
\item Line 16 essentially computes in which quarter of the row class size the current retrograded or retrograde-inverted top entry lies. If the row size is $n$, it stores a value $k \in \{0, n, 2n, 3n\}$. These values correspond respectively to the start indices of the transpositions, inversions, retrogrades and retrograde inversions within the row class.
\addtocounter{enumi}{1}
\item Line 18 checks whether the current top entry, after being retrograded or retrograde inverted, and transposed so that the last (now first) top entry starts with zero, is less than the top entry given at the current index of iteration, that is the non-transformed top entry read form left to right. If the former is less than the latter, then this top or some transform thereof has not been processed yet, as tops are traversed in lexicographic order. In that case, line 19 returns false.
\addtocounter{enumi}{1}
\item Line 20 tests the opposite case, where the transformed top entry seen from right to left is greater than the non-transformed entry seen form left to right. If that is the case, this top or some transform that leads to it has already been processed and thus line 21 returns true.
\addtocounter{enumi}{3}
\item If line 24 is reached, then every transformed top entry seen from right to left is equal to the corresponding non-transformed entry seen form left to right, which indicates that the top is retrograde or retrograde inverse-invariant. The algorithm then returns false. Since the first element of every top is always zero, line 24 can only be reached if the top at hand is being seen for the first time. Note that there are exceptions to the rule that every top's first element is zero, which shall be discussed in conjunction with Listing~\ref{writeSolutions}.
\end{enumerate}

%--------------------------------------------------------------------------
The purpose of Listing~\ref{unseen} is also to filter out tops that can be achieved from a previously seen top through some transformation, only that Listing~\ref{unseen} handles the cases where the row is retrograde or retrograde inverse-invariant. The general idea is the same: compute the retrograde or retrograde inverse-invariant transform of the top, transposing it so it starts with zero. Then compare with the original top, read from left to right, and return true if there is an entry in the transformed top greater than the corresponding entry in the original top, or if there are no entries in the transformed top less than the corresponding entry in the original top, implying the top is retrograde or retrograde inverse-invariant. Listing~\ref{unseen} utilizes the retrograde and retrograde inverse maps contained in the thread-common data structure, as filtering out tops may depend on the row at hand if the row is retrograde or retrograde inverse-invariant.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a top has not yet been seen for retrograde or retrograde inverse-invariant rows.},label={unseen}]
bool unseen(const number *top, common_data *cd) {
    number last = cd->problemSize - 1;
    number offset = cd->rMap[top[last]];
    bool invert = offset >= cd->rowSize;

    if (invert)
        offset = cd->riMap[top[last]];

    for (number i = 1; i < cd->problemSize; ++i) {
        number front = top[i];
        number back = invert ? cd->riMap[top[last - i]] : cd->rMap[top[last - i]];

        if (back < cd->rowSize)
            back = modulo(back - offset, cd->rowSize);
        else {
            back = modulo(back - offset - cd->rowSize, cd->rowSize);
            back += cd->rowSize;
        }

        if (back > front)
            return true;
        else if (back < front)
            return false;
    }

    return true;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the memory addresses of a top row and of a thread-common data structure. Unlike Listing~\ref{unseen}, the output is a boolean representing whether the top has not yet been seen.
\item Line 2 stores in a variable the index of the last row in the top. Line 3 uses the retrograde map to compute the transposition index of the top's last entry, assuming that the retrograde of the top is not inverted. Line 4 checks if the top's last entry is inverted and stores the result.
\addtocounter{enumi}{3}
\item Line 6 uses the result of the test computed in line 4 and, if the retrograde of the top is indeed inverted, line 7 corrects the wrong assumption made in line 3, using this time the retrograde inverse map to update the transposition index of the top's last entry.
\addtocounter{enumi}{2}
\item Line 9 iterates through the entries in the top, skipping the comparison between its first and last entries. Since the row class does not contain any retrograde transforms, the result of the comparison between the first and last entries here would be trivial. Line 10 stores the current leftmost entry, and line 11 stores the current rightmost entry, using the value computed in line 4 to determine if the retrograde or the retrograde inverse map should be used to retrieve the rightmost entry.
\addtocounter{enumi}{3}
\item Line 13 tests if the current rightmost entry is not inverted, in which case line 14 transposes it using the previously computed transposition index.
\addtocounter{enumi}{2}
\item If the current rightmost entry is in fact inverted, lines 16 and 17 use the previously computed transposition index to transpose and invert the current rightmost entry.
\addtocounter{enumi}{3}
\item Line 20 simply tests if the current rightmost entry is greater than the current leftmost entry and, if so, line 21 returns true.
\addtocounter{enumi}{1}
\item Line 22 tests the opposite scenario, and line 23 returns false if the current rightmost entry is less than the current leftmost entry.
\addtocounter{enumi}{3}
\item If line 26 is reached, then the top is is retrograde or retrograde inverse-invariant, so the algorithm returns true.
\end{enumerate}

%--------------------------------------------------------------------------
Listing~\ref{fillTop} is used as a subroutine in Listing~\ref{writeSolutions} to copy the top to be processed by Listing~\ref{allSolutionsRecursive} into the thread-specific data structure's scratch area for the top vector. A top, as computed in Listing~\ref{allTopsRecursive}, is an array of indices into the row class array. Listing~\ref{fillTop} iterates through the problem size, and copies the appropriate row transform from the row class array into the current column offset of the top row scratch area.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Refreshing the top row scratch area.},label={fillTop}]
void fillTop(thread_data *d, common_data *cd, const number *combo) {
    for (number i = 0; i < cd->problemSize; ++i)
        memcpy(&d->currentTop[i * cd->rowSize],
               &cd->rowClass[combo[i] * cd->rowSize],
               cd->rowSize * sizeof(number));
}
\end{lstlisting}

%--------------------------------------------------------------------------
Listing~\ref{writeSolutions} processes a range of tops and writes all solutions found into a text file. It relies on thread-specific data, so its execution should be constrained to a single thread. Multiple parallel calls to Listing~\ref{writeSolutions} can be made from different thread contexts, provided that each thread maintains their own thread-specific data structures. Listing~\ref{writeSolutions} also expands the provided range of tops when the row at hand is not retrograde or retrograde inverse-invariant. That is accomplished by processing the range of tops twice, the second time replacing the first entry in the top, which is always zero, with half the row class size, which is the index of the $RT_0$ transform. The reason is because some tops cannot be achieved by transforming the results of Listing~\ref{allTopsRecursive} alone. As a simple example, consider the case where $r$ is a row of size $n$ that is not retrograde or retrograde inverse-invariant, such that the size of its row class is $4n$. Let $T = \{0, 24\} = \{T_0, RT_0\}$ be a top. In particular, $T$ is one of the tops in the output of Listing~\ref{allTopsRecursive}. However, the retrograde of $T$ is the top

\begin{equation}
    R(T) = \{R(RT_0), R(T_0)\} = \{T_0, RT_0\} = \{0, 24\} = T \enspace.
\end{equation}

\noindent This shows that, in order to achieve some tops in which the first entry is a retrograde transform, such as $\tilde{T} = \{24, 0\}$, it is necessary that the top's first entry be a retrograde transform and not zero. It is sufficient that this first entry be $2n = RT_0$, since other tops in which the first entry is a retrograde transform can then be achieved by transformation under transposition, inversion or both. To see this, let $m$ be the problem size and let

\begin{equation}
    G = \underbrace{RT_xI \times \cdots \times RT_xI}_{m \; \text{times}} \enspace.
\end{equation}

\vspace{12pt}

\noindent The action of $RT_xI$ on $G$ by right multiplication induces orbits of two sizes, depending on whether $g \in G$, which is a top, is retrograde or retrograde inverse-invariant. If so, the orbit has size $2n$, otherwise the orbit has size $4n$. In the latter case, all orbits have a representative in which the first entry is zero. In the former case, all orbits have either a representative in which the first entry is zero, or one in which the first entry is $2n$.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Writing a text file with all solutions for a row class within a range of tops.},label={writeSolutions}]
length writeSolutions(thread_data *d, common_data *cd, length startTop, length endTop) {
    length topCounter = 0;
    FILE *solutionsFile = createSolutionsFile(&cd->rowClass[0], cd->problemSize, cd->rowSize, startTop, endTop);

    for (range first = 0; first < cd->classSize; first += cd->classSize / 2) {
        for (length i = startTop; i < endTop; ++i) {
            number *combo = &cd->allTops[i * cd->problemSize];
            combo[0] = first;

            if (cd->isInvariant && first >= cd->classSize / 2)
                break;

            if (cd->isInvariant && !unseen(combo, cd))
                continue;

            if (!cd->isInvariant && seen(combo, cd))
                continue;

            fillTop(d, cd, combo);
            memcpy(d->tmpTops, d->currentTop, cd->topSize * sizeof(number));
            memset(d->currentSum, 0, cd->problemSize * sizeof(number));
            allSolutionsRecursive(d, cd, solutionsFile, 0);
            topCounter++;
        }
    }

    fclose(solutionsFile);
    return topCounter;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{enumerate}
\item The inputs are the memory addresses of a thread-common and a thread-specific data structures, as well as the start and end top indices to be covered. The output is the actual number of tops that were processed.
\item Line 2 declares a variable to hold the total number of processed tops. Line 3 is a call to Listing~\ref{createSolutionsFile} to create and store a FILE pointer to which the computed solutions will be written.
\addtocounter{enumi}{2}
\item Line 5 iterates twice over the row class size to change the top's first entry from zero to half the row size in the second iteration, as discussed above. Line 6 iterates over the provided range of tops. Line 7 stores the memory address of the current top being processed, and line 8 changes the top's first entry.
\addtocounter{enumi}{4}
\item Line 10 checks if the row is retrograde or retrograde inverse-invariant and if the current top's first entry is not zero, in which case line 11 breaks the for-loop.
\addtocounter{enumi}{2}
\item Line 13 checks if the row is retrograde or retrograde inverse-invariant and if the current top can be achieved by transforming another top already seen by calling Listing~\ref{unseen}, in which case line 14 skips this iteration.
\addtocounter{enumi}{2}
\item Line 16 checks if the row is not retrograde or retrograde inverse-invariant and if the current top can be achieved by transforming another top already seen by calling Listing~\ref{seen}, in which case line 17 skips this iteration.
\addtocounter{enumi}{2}
\item Line 19 is a call to Listing~\ref{fillTop} to refresh the top row's scratch area. Line 20 copies the current top into the bottom of the top stack, and line 21 sets all entries in the scratch area for square column sums to zero. Line 22 then calls Listing~\ref{allSolutionsRecursive} to compute and output solutions, and line 23 increases the top counter.
\addtocounter{enumi}{7}
\item Line 27 closes the solutions file and line 28 returns the number of tops actually processed.
\end{enumerate}
