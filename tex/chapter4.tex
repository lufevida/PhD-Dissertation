%--------------------------------------------------------------------------
\chapter{THEORETICAL FRAMEWORK}

This section proposes a model to describe derivation in a general setting. After writing the chapter, Luis will come back here and summarize what he wrote.

%TODO: This problem is NP-hard and is a satisfiability problem similar to Sudoku and the 8-Queens.

%--------------------------------------------------------------------------
\section{Defining an algorithm to compute a row class}

In a traditional setting, a composer will usually define a class of transforms of a basic row by computing by hand what is commonly termed as a 12-tone matrix. The general procedure is usually to fill the top row of the matrix with a transform of the row beginning with zero. The second step is to fill the leftmost column of the matrix with the inverse transform of the top row. The subsequent steps comprise going row-by-row and filling them with a transposition of the top row. The particular transposition for each row is the first pitch-class of the row. So if a row begins with, say, pitch-class $5$, then the entire row will be the $T_5$ transform of the top row. Then 12-tone matrix will hold all 48 transforms of a row: reading every row from left to right gives all transpositions, reading them from right to left gives all retrogrades, reading all columns from top to bottom gives all inversions, and reading them from bottom to top gives all retrograde inversions.

Although somewhat tedious, computing 12-tone matrices by hand is a well-established procedure. The 48 transforms that can be inferred from the matrix are not necessarily unique, given that a 12-tone may be retrograde, or retrograde-inverse invariant. It is straightforward to generalize the procedure to $n$-tone matrices. However, the graphical idea of reading the matrix from right to left, or bottom to top, is not ideal for computing self-deriving combination matrices, as it is faster to read a transform of a row that is written contiguously in memory. Another caveat is that the procedure does not necessarily define a canonical form for the top row. Every row in a matrix is a representative of an equivalence class of rows under the action of $RT_NI$. The size of each orbit is $4n$ if the row is not retrograde or retrograde-inverse invariant, and $2n$ otherwise. Defining a canonical form for the first row in a data structure that holds a row class is desirable in any algorithm that iterates through row classes in lexicographic order.

%--------------------------------------------------------------------------
\subsection{The canonical form of a row}

This section describes an algorithm to obtain a canonical form for a row. The canonical form defined here is simply the least element in a lexicographic ordering of a row class. Given an arbitrary representative of a row class, that representative will be considered retrograded if any interval class between two consecutive elements of the row, counted from right to left, is strictly less than the corresponding interval class counted from left to right. Finding the interval class between two pitch-classes is illustrated in Listing~\ref{intervalClass}, which takes as input two pitch-classes $a$ and $b$, and the base $n$, returning the interval class between the two. The interval class between $a \pmod n$ and $b \pmod n$ is expressed mathematically as $\min\{(a - b) \pmod n, (b - a) \pmod n\}$.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Computing the interval class between two pitch-classes.},label={intervalClass}]
number intervalClass(number a, number b, number rowSize) {
    number interval = abs(a - b);
    return min(interval, rowSize - interval);
}
\end{lstlisting}

\begin{enumerate}
\item \emph{intervalClass} takes as input two pitch-classes $a$ and $b$, as well as the base $n$ so that $a, b \in \mathbb{Z} / n \mathbb{Z}$.
\item Line 2 simply computes the distance between $a$ and $b$.
\item Line 3 returns the least between the above interval and its complement, that is, the interval class between the two given pitch-classes.
\end{enumerate}

The procedure for determining whether a row is retrograded utilizes Listing~\ref{intervalClass} as a subroutine, and is outlined in Listing~\ref{isRetrograded}. The sole parameter to Listing~\ref{isRetrograded} is the row at hand, which can be any of the representatives of its row class, and the returned value is a boolean indicating whether the row is retrograded or not.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a representative of a row class is retrograded.},label={isRetrograded}]
bool isRetrograded(const number *row, number rowSize, bool isInvariant) {
    if (isInvariant || rowSize < 5)
        return false;

    number front, back;

    for (number i = 0; i < rowSize; ++i) {
        front = intervalClass(row[i + 1], row[i], rowSize);
        back = intervalClass(row[rowSize - i - 1], row[rowSize - i - 2], rowSize);

        if (back < front)
            return true;
    }

    return false;
}
\end{lstlisting}

\begin{enumerate}
\item \emph{isRetrograded} has three parameters, namely a pointer to a row, its size, and a boolean representing whether the row is retrograde or retrograde inverse-invariant.
\item Lines 2 and 3 perform a straightforward sanity check. It will be shown below that all rows of size 4 or less are necessarily retrograde or retrograde-invariant. If a row with 5 or more elements is known to be invariant, we skip the test.
\addtocounter{enumi}{2}
\item Line 5 declares the variables that will represent interval classes seen from left to right, and from right to left, respectively.
\addtocounter{enumi}{2}
\item Lines 8 and 9 simply update the variables front and back using Listing~\ref{intervalClass} defined above. As $i$ increases, front traverses all interval classes in the row from left to right, whereas back does the same from right to left, that is, back looks at the row as if it were retrograded.
\addtocounter{enumi}{2}
\item Line 11 compares the front and back interval classes and line 12 returns true if any interval class seen from right to left is strictly less than the corresponding interval class seen from left to right, which would indicate that retrograding the row would produce a lexicographically lower-positioned row than the one given as input.
\addtocounter{enumi}{3}
\item If all interval classes seen from both directions are equal, then the row is retrograde or retrograde inverse-invariant. Line 15 then returns false to avoid unnecessarily reversing a row that is invariant.
\end{enumerate}

The next step in determining the canonical form of a row consists of finding whether its inverse has a lower lexicographic position within the row class. The procedure is described in Listing~\ref{isInverted}, which in turn depends on two small subroutines, namely Listing~\ref{modulo} and Listing~\ref{isOwnInverse}. The former simply computes $modulo(x, n) = x \pmod{n}$. However, it needs to be defined in a subroutine this way because the result of C-language built-in modulo operator is signed, and for practical reasons that will be elaborated below, it is best that all pitch-classes be represented as unsigned integers ranging from $0$ to $n - 1$.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={A subroutine to compute $x \pmod{n}$ such that the result is non-negative.},label={modulo}]
number modulo(number x, number base) {
    x %= base;
    return x < 0 ? x + base : x;
}
\end{lstlisting}

\begin{enumerate}
\addtocounter{enumi}{1}
\item Line 2 simply computes $x \pmod{n}$ using the C-language built operator.
\item Line 3 then returns then same congruence class but in the range $[0, n - 1]$.
\end{enumerate}

Listing~\ref{isOwnInverse} is a simple convenience method that is used to check whether $x \equiv X \pmod{n}$, which is also needed in Listing~\ref{isInverted}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={A subroutine that returns true if a pitch-class is its own inverse.},label={isOwnInverse}]
bool isOwnInverse(number x, number base) {
    return x == 0 || x == base - x;
}
\end{lstlisting}

\begin{enumerate}
\item The input $x$ is assumed to be in the range $[0, n - 1]$.
\item Since $x$ is non-negative, it can only be its own inverse if it is the identity, or if $x \equiv -x \pmod{n}$. It is also possible to check that if $n$ is even and $x$ is equal to $n / 2$, then $x$ is its own inverse. But this alternative method is far more computationally expensive that the one in Listing~\ref{isOwnInverse}.
\end{enumerate}

In order to determine whether the inverse transform of a row has a lower lexicographical position than itself, it is necessary in this implementation to consider if its retrograde transform also sits in a lower lexicographical position. The reason for that is because the input row has not been transformed at all up to this point. A prerequisite to calling Listing~\ref{isInverted} is to have previously called Listing~\ref{isRetrograded}, the result thereof being used as one of the inputs to Listing~\ref{isInverted}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a representative of a row class is inverted.},label={isInverted}]
bool isInverted(const number *r, number rowSize, bool R) {
    if (R) {
        for (number i = rowSize - 1; i >= rowSize / 2; --i) {
            number mod = modulo(r[i] - r[rowSize - 1], rowSize);

            if (!isOwnInverse(mod, rowSize))
                return mod > rowSize - mod;
        }
    } else {
        for (number i = 0; i < rowSize / 2; ++i) {
            number mod = modulo(r[i] - r[0], rowSize);

            if (!isOwnInverse(mod, rowSize))
                return mod > rowSize - mod;
        }
    }

    return false;
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are a row, its size, and a boolean representing whether the row is retrograded.
\addtocounter{enumi}{1}
\item If $r$ is retrograded, line 3 begins iteration in reverse order, that is, starting with the last element of the row.
\item Line 4 computes the ordered interval between the pitch-class at hand, and the first pitch-class of the row, which in this case is the last because the row is retrograded.
\addtocounter{enumi}{1}
\item Line 6 checks if the interval is not its own inverse and, if not, line 7 checks if the interval is greater than its inverse. If so, an inverted form of the row would sit in a lower lexicographical position within the entire row class, and the row is inverted.
\addtocounter{enumi}{3}
\item If the input row is not retrograded, then lines 10 to 14 perform essentially the same check as the previous branch, only traversing the row from left to right, instead of the right to left traversal done for a retrograded row. In both branches, it is important to note that the loops iterate at most twice. If the row size is odd, then the very first iteration will decide if the row is inverted. If, on the other hand, the row size is even, then there is the possibility that the very first interval will be its own inverse, in which case the next iteration will invariably be able to tell if the row is inverted.
\addtocounter{enumi}{7}
\item Line 18 should never be reached for well-defined inputs, and is included for correctness.
\end{enumerate}

Determining that an arbitrary representative of a row class is retrograded or inverted are essential subroutines used in Listing~\ref{getCanonicalForm}, which in turn does transform the input row into its canonical form. This transformation happens in Listing~\ref{getTransformInPlace}, and the latter relies on a straightforward method to in-place swap row entries, described below in Listing~\ref{swapInPlace}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Swapping two entries in a row.},label={swapInPlace}]
void swapInPlace(number *row, number i, number j) {
    number tmp = row[i];
    row[i] = row[j];
    row[j] = tmp;
}
\end{lstlisting}

The procedure in Listing~\ref{swapInPlace} is very common-place, so the details are omitted. Listing~\ref{getTransformInPlace} is also straightforward and represents the main subroutine in Listing~\ref{getCanonicalForm}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Transforming a row in place.},label={getTransformInPlace}]
void getTransformInPlace(number *row, number rowSize, number T, bool I, bool R) {
    if (R) {
        for (number i = 0; i < rowSize / 2; ++i)
            swapInPlace(row, i, rowSize - 1 - i);
    }

    if (I) {
        for (number i = 0; i < rowSize; ++i)
            row[i] = (rowSize - row[i] + T) % rowSize;
    } else if (T != 0 % rowSize) {
        for (number i = 0; i < rowSize; ++i)
            row[i] = (row[i] + T) % rowSize;
    }
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are a row, its size, a non-negative integer representing an offset to be added to the entire row, a boolean representing whether the row is inverted, and another boolean representing whether the row is retrograded.
\addtocounter{enumi}{1}
\item If the row is retrograded, lines 3 and 4 simply reverse the row using Listing~\ref{swapInPlace}.
\addtocounter{enumi}{4}
\item If the row is inverted, lines 8 and 9 invert the row and add the offset to each row entry.
\addtocounter{enumi}{2}
\item Otherwise, if the row is not inverted, lines 11 and 12 only add the offset to the entire row.
\end{enumerate}

The procedure illustrated in Listing~\ref{getTransformInPlace} is used below in Listing~\ref{getCanonicalForm}, but it will also be used many times over to construct a row class in memory. In the particular case where the canonical form of the row is desired, that is, the lowest element in a lexicographical ordering of the row class, the offset used will be the additive inverse of the row's first element. It is important to observe that Listing~\ref{getCanonicalForm} requires prior knowledge as to whether the row is retrograde or retrograde inverse-invariant. In the grand scheme of things, that knowledge will already be available when calling Listing~\ref{getCanonicalForm}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Transforming a row into its canonical form.},label={getCanonicalForm}]
void getCanonicalForm(number *row, number rowSize, bool isInvariant) {
    bool R = isRetrograded(row, rowSize, isInvariant);
    bool I = isInverted(row, rowSize, R);
    number T = row[R ? rowSize - 1 : 0];
    getTransformInPlace(row, rowSize, I ? T : rowSize - T, I, R);
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are a row, its size, and whether the row is retrograde or retrograde inverse-invariant.
\item Lines 2 and 3 simply call Listing~\ref{isRetrograded} and Listing~\ref{isInverted} respectively, storing the results.
\addtocounter{enumi}{1}
\item Line 4 just stores the first element of the row, which may be the last if the row is retrograded.
\item Line 5 is a call to Listing~\ref{getTransformInPlace}. The third argument is the additive inverse of the row's start element. It varies, naturally, if the row is inverted.
\end{enumerate}

%--------------------------------------------------------------------------
\subsection{Storing a row class in memory}

The purpose of the procedures described in this section is to store an entire row class contiguously in memory. That consists of creating an array large enough to hold all transforms of a row, and copying sequentially into this array said transforms. Even for rows whose base are considered large, a row class under $RTN_I$ is still very small. Thus holding these transforms in memory makes sense for execution speed purposes. The size of the row class array depends on whether the row is reverse or reverse inverse-invariant. The row class array begins with the canonical for of the row, followed by all its transpositions, in ascending order, followed by all transpositions of the inversion of the canonical for, also in ascending order. If the row is not reverse or reverse inverse-invariant, the row class array is appended by all transpositions of the reverse of the canonical order, followed by all transpositions of the retrograde inverse of the canonical order. Therefore, the overall size of the row class array is $2n^2$ if the row is retrograde or retrograde inverse-invariant, or $4n^2$ otherwise, where $n$ is the row size. The main routine for creating the row class array is described below in Listing~\ref{getRowClass}. It depends on two subroutines, namely Listing~\ref{isRetrogradeInvariant} and Listing~\ref{isRetrogradeInverseInvariant} that are described below.

%--------------------------------------------------------------------------
\begin{lemma}
	\label{retrograde-invariance}
	In a retrograde-invariant row, the interval between every entry seen from left to right, and the corresponding entry seen from right to left, must equal half the size of the row.
	\begin{proof}
	\end{proof}
\end{lemma}

%--------------------------------------------------------------------------
\begin{corollary}
	\label{odd-retrograde-invariance}
	A row with odd size greater than $3$ cannot be retrograde-invariant.
	\begin{proof}
	\end{proof}
\end{corollary}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a row is retrograde-invariant.},label={isRetrogradeInvariant}]
bool isRetrogradeInvariant(const number *row, number rowSize) {
    if (rowSize > 3 rowSize % 2 == 1)
        return false;

    number half = rowSize / 2;

    for (number i = 0; i < half; ++i) {
        if (modulo(row[rowSize - i - 1] - row[i], rowSize) != half)
            return false;
    }

    return true;
}
\end{lstlisting}

\begin{enumerate}
\item The only inputs are a row and its size.
\item Line 2 utilizes Th.~\ref{odd-retrograde-invariance} as a sanity check. If the test in line 2 succeeds, line 3 returns false.
\addtocounter{enumi}{2}
\item Line 5 just computes half the row size for convenience. Retrograde-invariance can be determined by iterating through at most half the size of the row.
\addtocounter{enumi}{1}
\item Line 7 iterates through the row from left to right, and line 8 applies Th.~\ref{retrograde-invariance}. Line 9 then returns false if any of the intervals is not equal to half the row size.
\addtocounter{enumi}{4}
\item If all pairs coming from both directions are equal to half the row size, then the row is retrograde-invariant and line 12 returns true.
\end{enumerate}

Unlike retrograde-invariance, every row size can produce retrograde inverse-invariance. A simple example is the lowest lexicographically-order row of any size, that is, a chromatic scale. Retrograding, inverting, and transposing by $-1$ always yields back the initial row. Listing~\ref{isRetrogradeInverseInvariant} outlines the procedure in all generality.

%TODO: when row size is odd, and all pairs sum to x, will the single element plus itself sum to x?

%--------------------------------------------------------------------------
\begin{lemma}
	\label{retrograde-inverse-invariance}
	In a retrograde inverse-invariant row $r$, the interval between every entry seen from left to right, and the corresponding entry seen from right to left, must be equal to $r_0 + r_{n - 1} \pmod{n}$, where $n$ is the base of the row.
	\begin{proof}
	\end{proof}
\end{lemma}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Determining whether a row is retrograde inverse-invariant.},label={isRetrogradeInverseInvariant}]
bool isRetrogradeInverseInvariant(const number *row, number rowSize) {
    number half = rowSize / 2;
    number first = modulo(row[rowSize - 1] + row[0], rowSize);

    for (number i = 1; i < half; ++i) {
        if (modulo(row[rowSize - i - 1] + row[i], rowSize) != first)
            return false;
    }

    return true;
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are a row and its size.
\item Line 2 computes half the row size for convenience. Like Listing~\ref{isRetrogradeInvariant}, retrograde inverse-invariance can be determined by traversing only half the row size.
\item Line 3 computes $r_0 + r_{n - 1} \pmod{n}$ for later use.
\addtocounter{enumi}{1}
\item Line 5 begins iteration from the second entry onward, since the first pair was already computed in line 3. Line 6 then compares the subsequent corresponding pairs, and line 7 returns false if any of them is not equal to the first pair.
\addtocounter{enumi}{4}
\item If line 10 is reached, it means the row is retrograde inverse-invariant, so the algorithm returns true.
\end{enumerate}

The procedure to compute and store an entire row class in memory is outlined below in Listing~\ref{getRowClass}. It returns a memory address that must be freed by the caller. While computing combination matrices of self-derivation, this memory location will be held for the duration of the program, and possibly also be shared by many different threads of execution. The procedure makes heavy use of Listing~\ref{getTransformInPlace} to sequentially store in memory all transforms of the canonical form of the row. It also takes the input row and transforms it in-place into its canonical form. Any representative of a row class can therefore be used to construct a row class with Listing~\ref{getRowClass}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Computing and storing a row class in memory.},label={getRowClass}]
number *getRowClass(range *classSize, number *row, number rowSize, bool isInvariant) {
    getCanonicalForm(row, rowSize, isInvariant);
    *classSize = isInvariant ? rowSize * 2 : rowSize * 4;

    number *rowClass = malloc(rowSize * *classSize * sizeof(number));
    memcpy(rowClass, row, rowSize * sizeof(number));

    for (number i = 1; i < rowSize; ++i) {
        number *rep = &rowClass[i * rowSize];
        memcpy(rep, rowClass, rowSize * sizeof(number));
        getTransformInPlace(rep, rowSize, i, false, false);
    }

    for (number i = rowSize; i < rowSize * 2; ++i) {
        number *rep = &rowClass[i * rowSize];
        memcpy(rep, rowClass, rowSize * sizeof(number));
        getTransformInPlace(rep, rowSize, i, true, false);
    }

    if (*classSize == rowSize * 2)
        return rowClass;

    for (number i = rowSize * 2; i < rowSize * 3; ++i) {
        number *rep = &rowClass[i * rowSize];
        memcpy(rep, rowClass, rowSize * sizeof(number));
        getTransformInPlace(rep, rowSize, i, false, true);
    }

    for (number i = rowSize * 3; i < rowSize * 4; ++i) {
        number *rep = &rowClass[i * rowSize];
        memcpy(rep, rowClass, rowSize * sizeof(number));
        getTransformInPlace(rep, rowSize, i, true, true);
    }

    return rowClass;
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are a pointer to the size of the row class, which will be computed by Listing~\ref{getRowClass} and stored in the address provided, a row, its size, and a boolean representing whether the row is retrograde or retrograde inverse-invariant. This boolean will be computed by the caller before calling Listing~\ref{getRowClass}, utilizing the aforementioned procedures Listing~\ref{isRetrogradeInvariant} and Listing~\ref{isRetrogradeInverseInvariant}. The output is a memory location containing the entire row class.
\item As mentioned above, line 2 simply computes the canonical form of the given row in place.
\item Line 3 computes the class size based on whether the row is retrograde or retrograde inverse-invariant. It is important to notice here that the row class size is not the length of the row class array, but the number of transforms of the canonical form that the row class array contains. This number is stored in the address provided by the caller.
\addtocounter{enumi}{1}
\item Line 5 allocates in the heap the memory space that will be used to store the entire row class, and line 6 copies the canonical form of the row to the beginning of this allocated space.
\addtocounter{enumi}{2}
\item Line 8 starts from the second row in the row class, which is the first transposition of the canonical form, and the block adds all subsequent transpositions to the row class. Line 9 computes the address where the current transposition should start, line 10 copies the canonical for of the row into this address, and line 11 transforms the canonical for into the desired transposition in place. 
\addtocounter{enumi}{5}
\item Line 14 starts from the thirteenth row in the row class, that is, the $T_0I$ transform of the row. Lines 15 to 17 add the subsequent $T_nI$ transforms of the canonical for of the row in the same way the $T_n$ transforms were added above, only specifying in the call to Listing~\ref{getTransformInPlace} that the transforms now need to be inverted.
\addtocounter{enumi}{5}
\item Line 20 checks if the row is retrograde or retrograde inverse-invariant and, if so, halts the process and returns the memory location allocated in line 5.
\addtocounter{enumi}{2}
\item If the row is is retrograde or retrograde inverse-invariant, lines 23 to 26 add all $RT_n$ transforms of the row to the row class as above.
\addtocounter{enumi}{5}
\item Similarly, lines 29 to 32 add all the $RT_nI$ transforms of the row.
\addtocounter{enumi}{5}
\item Line 36 then simply returns the memory location allocated in line 5.
\end{enumerate}

%--------------------------------------------------------------------------
\section{Defining an algorithm to compute semi-magical squares}

A key component in the definition of a combination matrix of self-derivation is a semi-magic square. By definition, a semi-magic square is a square matrix where the sum of all elements, for each row and column, is a constant. For our purposes, that constant will be the base $n$ of the row. Seeing each entry in a semi-magic square as a real number and dividing each entry in the matrix by $n$ produces a doubly stochastic matrix, in which every row and every column sum to one. A magic square is a semi-magic square where, in addition, both main diagonals add up to the same constant as the rows and columns.

%--------------------------------------------------------------------------
\subsection{Computing the partitions of an integer}

By the definition above of a semi-magic square, every row therein is a permutation of an integer partition of $n$. In fact, every column is also a permutation of an integer partition of $n$, but the algorithm described below in Listing~\ref{allPartitionsRecursive} shall concentrate on computing all integer partitions of $n$ and their permutations as rows that will ultimately become the rows of a semi-magic square. Since these integer partitions of $n$ are completely independent of the row at hand, they can be computed only once for each $n$ and stored as a file, speeding up the process of computing combination matrices for other rows. Before describing Listing~\ref{allPartitionsRecursive}, a couple subroutines for reading and writing files are outlined.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Retrieving the size of a file.},label={getFileSize}]
long getFileSize(FILE *file) {
    fseek(file, 0, SEEK_END);
    long fileSize = ftell(file);
    fseek(file, 0, SEEK_SET);
    return fileSize;
}
\end{lstlisting}

Listing~\ref{getFileSize} is a completely common-place procedure in the C-language, and its details are omitted. It is used as a subroutine in Listing~\ref{readFile}, which is described next.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Reading the contents of a file.},label={readFile}]
number *readFile(const char *fileName, length *numLines, number problemSize) {
    FILE *file = fopen(fileName, "rb");

    if (file == NULL)
        return NULL;

    long fileSize = getFileSize(file);
    number *buffer = malloc(fileSize);
    *numLines = (length) (fileSize / sizeof(number)) / problemSize;
    fread(buffer, fileSize, 1, file);
    fclose(file);

    return buffer;
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the file name, assuming both the main executable and the file are in the same folder, a memory address where the number of lines read will be stored, and the problem size, which is the size of the magic square. The output is a memory location with the contents of the file, or a NULL pointer if the operation fails.
\item Line 2 simply opens the file at the given path for reading. Line 4 performs a sanity check and line 5 returns a NULL pointer if the file cannot be read.
\addtocounter{enumi}{4}
\item Line 7 is a call to Listing~\ref{getFileSize} so that the correct amount of memory can be allocated. The value computed in line 7 is already in bytes. Line 8 then allocates the memory whose address will be returned.
\addtocounter{enumi}{1}
\item Line 9 computes the number of lines in the file, that is, the number of integer partitions of $n$ with length \emph{problemSize} that have been previously computed and stored in the file. The value is then stored in the memory address provided in the input list to store the number of lines in the file.
\item Line 10 simply reads the entire contents of the file into the buffer allocated in line 8, line 11 frees the FILE data structure created in line 2, and line 13 returns the allocated memory. It is the responsibility of the caller to free this memory when no longer needed.
\end{enumerate}

The procedure described in Listing~\ref{writeAllPartitions} effectively writes all integer partitions of $n$ with a certain size to a file. It depends on Listing~\ref{allPartitionsRecursive} to compute all said partitions recursively, which is described next. One important feature of Listing~\ref{allPartitionsRecursive} is that it skips partitions whose all but one entries are zero. The reason for this is because the remaining entry would be forced to be equal to $n$. In any semi-magic square where there is an entry equal to $n$, both the row and column to which this entry belongs will necessarily contain only zeros except, of course, for the entry with value $n$. This means that the linearized top of the combination matrix at that semi-magic square's column will inevitably be trivially polyphonized, that is, the corresponding square cell would simply have the entire row at the top. Therefore any combination matrix can be extended by adding a column and a row at an arbitrary indices, and making that square entry contain $n$ elements, that is, a linearized statement of a row form. Since this procedure is completely general, the semi-magic squares computed below include entries only up to $n - 1$.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all partitions of a number $n$ and permutations thereof with a certain size.},label={allPartitionsRecursive}]
void allPartitionsRecursive(number *tmp, number currentSize, number problemSize, number currentSum, number rowSize, FILE *file) {
    if (currentSize == problemSize - 1) {
        if (currentSum > 0) { // skip the [0, ..., 0, rowSize] partition
            tmp[currentSize] = rowSize - currentSum;
            fwrite(tmp, sizeof(number), problemSize, file);
        }

        return;
    }

    for (number i = 0; i < rowSize; ++i) {
        if (i + currentSum <= rowSize) {
            tmp[currentSize++] = i;
            allPartitionsRecursive(tmp, currentSize, problemSize, i + currentSum, rowSize, file);
            currentSize--;
        }
    }
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the address of some scratch memory previously allocated with the same length of the problem size, the current number of entries already placed in the scratch memory, the problem size, the current sum of the entries in the scratch memory, the base $n$, and a pointer to a FILE data structure where the partitions will be stored, line by line.
\item Line 2 deals with the base case of the recursion, that is, when the current number of elements in the scratch memory is one less than the problem size. If that is the case, then the last element in the scratch memory array must be equal to $n$ minus the sum of all previous elements.
\item Line 3 deals with the edge case where all entries up to problem size minus one are zero. That would force the very last element of the scratch memory array to be equal to $n$ which, by the discussion above is avoided in this implementation.
\item Line 4 sets the last element of the scratch memory array to $n$ minus the sum of its previous elements and line 5 writes the current partition to the given file. Having completed an entire partition, line 8 returns, so the function recurses no further.
\addtocounter{enumi}{6}
\item For the recursion cases where the scratch memory array has been filled with less than problem size minus one elements, the loop in line 11 iterates from zero to $n - 1$. Line 12 is a sanity check that the sum of the current element being appended to the scratch memory array with the current sum of all elements so far introduced is no greater than $n$. Line 13 then appends the current element to the end of the scratch memory array, increases the current size counter, and line 14 pushes to the call stack another recursive call to Listing~\ref{allPartitionsRecursive}.
\addtocounter{enumi}{1}
\item Line 15 backtracks the current size so that all combinations of integers in the range $[0, n - 1]$ are tried.
\end{enumerate}

Listing~\ref{writeAllPartitions} described below is essentially a wrapper around Listing~\ref{allPartitionsRecursive}. Partitions files are saved in the same location where the main executable is built, in order to facilitate dealing with file paths. In general, these files are very small even for large $n$, but the speed gains in precomputing them are worthwhile, given the recursive nature of Listing~\ref{allPartitionsRecursive}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Writing all partitions to a file.},label={writeAllPartitions}]
void writeAllPartitions(number problemSize, number rowSize) {
    char fileName[32];
    sprintf(fileName, "all_partitions_%i_%i.dat", problemSize, rowSize);
    FILE *file = fopen(fileName, "wb");

    number *tmp = malloc(problemSize * sizeof(number));
    allPartitionsRecursive(tmp, 0, problemSize, 0, rowSize, file);

    free(tmp);
    fclose(file);
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are a problem size, which is the size of the semi-magic square, and a row size, which is the row base $n$.
\item Line 2 creates an array of 32 characters to hold the file name. This file name array length is large enough to accommodate all file names in this implementation. Line 3 writes the name of the file into the buffer defined in the previous line, and line 4 opens a C-type FILE for writing at the specified path.
\addtocounter{enumi}{3}
\item Line 6 allocates the scratch memory needed for the call to Listing~\ref{allPartitionsRecursive} in the following line. Being that Line 7 is the bottommost call on the call stack for Listing~\ref{allPartitionsRecursive}, the arguments given for the current size and current sum parameters are both zero.
\addtocounter{enumi}{2}
\item Line 9 frees the scratch memory used in the calls to Listing~\ref{allPartitionsRecursive}, and line 10 closes and releases the file created in line 4.
\end{enumerate}

The counterpart to Listing~\ref{writeAllPartitions} is Listing~\ref{readAllPartitions}, which is designed to not only read a partitions file, but to also generate one in case the particularly sought partitions file had not been previously created.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Reading all partitions from a file.},label={readAllPartitions}]
number *readAllPartitions(length *numPartitions, number problemSize, number rowSize) {
    char fileName[32];
    sprintf(fileName, "all_partitions_%i_%i.dat", problemSize, rowSize);

    number *allPartitions = readFile(fileName, numPartitions, problemSize);

    if (allPartitions == NULL) {
        printf("Writing partitions file...\n");
        writeAllPartitions(problemSize, rowSize);
        allPartitions = readFile(fileName, numPartitions, problemSize);
    }

    return allPartitions;
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are a memory address to store the number of lines in the partitions file to be read, the problem size and the row size. The output is a memory address with the contents of the partitions file. It is the responsibility of the caller to free the returned memory when no longer needed.
\item Lines 2 and 3 store the file name in a buffer, similarly to Listing~\ref{writeAllPartitions}.
\addtocounter{enumi}{2}
\item Line 5 attempts to read an existing file.
\addtocounter{enumi}{1}
\item Line 7 checks that the operation in line 5 succeeded. If it failed, lines 8 to 10 print to the console that a partitions file will be created, create the file by calling Listing~\ref{writeAllPartitions}, and attempt to read the file again.
\addtocounter{enumi}{5}
\item Line 13 simply returns the memory address with the contents of the file, or NULL if creating the file failed.
\end{enumerate}

%--------------------------------------------------------------------------
\subsection{Combining partition rows into squares}

This section describes an algorithm to combine integer partition rows into semi-magic squares. The overall procedure consists of appending integer partition rows to the square and adding the the rows as vectors. It is a backtracking recursive algorithm similar to Listing~\ref{allPartitionsRecursive}, the main difference being that the backtracking step consists of subtracting from the vector sum the previously added row after pushing onto the stack another recursive call. Adding two integer partition rows, seen as vectors, is described next in Listing~\ref{plus}.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Adding two vectors.},label={plus}]
void plus(number *a, const number *b, number problemSize) {
    for (number i = 0; i < problemSize; ++i)
        a[i] += b[i];
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the memory locations of two vectors and their size, which assumed to be the same.
\item Line 2 simply iterates through the length of the vectors and line 3 adds point-wise the second vector to the first.
\end{enumerate}

The counterpart to Listing~\ref{plus} is Listing~\ref{minus}. It is important to notice that vector addition and subtraction can be vectorized for speed, that is, SIMD instructions from the processor architecture at hand can replace much of the work the for-loops in Listing~\ref{plus} is Listing~\ref{minus} do to great effect. This option is not explored in this implementation, however. Details are omitted for Listing~\ref{minus}, as is essentially the same as Listing~\ref{plus}, only with the inverse operation.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Subtracting one vector from another.},label={minus}]
void minus(number *a, const number *b, number problemSize) {
    for (number i = 0; i < problemSize; ++i)
        a[i] -= b[i];
}
\end{lstlisting}

Listing~\ref{validate} is also used as subroutine in Listing~\ref{allSquaresRecursive} to validate whether the integer partition row that had just been added to the sum of rows vector does not violate the semi-magic square constraints.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Validating a sum of integer partition rows.},label={validate}]
bool validate(const number *currentSum, number problemSize, number rowSize) {
    for (number i = 0; i < problemSize; ++i) {
        if (currentSum[i] > rowSize)
            return false;
    }

    return true;
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the memory location of the current sum of rows, the problem size, and the row size $n$.
\item Line 2 iterates through the size of the magic square, checking in line 3 whether any entry in the current sum vector is already greater than $n$, fact that would violate the semi-magic square definition. If so, line 4 returns false.
\addtocounter{enumi}{4}
\item If all entries in the current sum vector are less than or equal to $n$, this is still a viable semi-magic square, so line 7 returns true.
\end{enumerate}

Listing~\ref{allSquaresRecursive} utilizes the previously computed integer partition rows to form all possible semi-magic squares of size $n$, with entries in the range $[0, n - 1]$. It is described here because it facilitates understanding of Listing~\ref{allSolutionsRecursive}, but it is not used in computing combination matrices of self-derivation. For the latter purpose, computing \emph{all} possible semi-magical squares would be impractical, but this discussion is deferred to the next sections. Although Listing~\ref{allSquaresRecursive} takes as input a pointer to a FILE data structure, a procedure to save all semi-magic squares is omitted, as the number of such squares is overwhelmingly large and grows with both the problem size and $n$.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all semi-magic squares of a certain size.},label={allSquaresRecursive}]
void allSquaresRecursive(number *tmp, number *currentSum, number currentSize, number problemSize, number rowSize, const number *partitions, length numPartitions, FILE *file) {
    if (currentSize == problemSize) {
        fwrite(tmp, sizeof(number), problemSize, file);
        return;
    }

    number start = 0;

    if (currentSize == 0)
        memset(currentSum, 0, problemSize * sizeof(number));
    else
        start = tmp[currentSize - 1];

    for (length i = start; i < numPartitions; ++i) {
        const number *p = &partitions[i * problemSize];
        plus(currentSum, p, problemSize);

        if (validate(currentSum, problemSize, rowSize)) {
            tmp[currentSize++] = i;
            allSquaresRecursive(tmp, currentSum, currentSize, problemSize, rowSize, partitions, numPartitions, file);
            currentSize--;
        }

        minus(currentSum, p, problemSize);
    }
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the memory address for some scratch memory where the semi-magical square will be stored as a sequence of indices into the integer partitions array. The size of this allocated memory must this be equal to the problem size. The memory address of another scratch memory space to hold the current sum of integer partition rows, with size equal to the problem size, the current number of rows already appended to the square, the problem size, the row size $n$, a pointer to the contents of a partitions file, previously computed using Listing~\ref{allPartitionsRecursive}, the total number of integer partition rows, and a pointer to a FILE data structure.
\item Line 2 deals with the base case of the recursion, that is, when all rows have been appended to the square. When that is the case, the algorithm writes the square to the file and returns.
\addtocounter{enumi}{4}
\item Line 7 defines a variable for where iteration of integer partition rows should start. This is a mechanism to avoid permutations of integer partition rows within a semi-magic square by enforcing that the rows of the constructed semi-magic square, seen as indices in the range between zero and the total number of integer partitions, be a nondecreasing sequence. The next section shall expand on the discussion of avoiding permutations of rows in semi-magical squares.
\addtocounter{enumi}{1}
\item Even though the current size is normally set to zero on a very first call to Listing~\ref{allSquaresRecursive}, the backtracking nature of the algorithm will push onto the call stack many other calls to Listing~\ref{allSquaresRecursive} where the current sum scratch memory might have been previously used, thus containing left over data. Line 9 then checks if the current size is zero, and line 10 sets all entries in the current sum scratch space to zero, to clear any left over data. If, on the other hand, the current size is greater than zero, then line 12 sets the start of the iteration to the very last index into the integer partition rows seen so far, guaranteeing that the sequence of indices in each square is nondecreasing.
\addtocounter{enumi}{4}
\item Line 14 begins iteration from the last index already in the square. In line 15, the variable \emph{p} stores the memory location of the integer partition row at the current index of iteration, and line 16 utilizes Listing~\ref{plus} to add this integer partition row to the current sum scratch memory.
\addtocounter{enumi}{3}
\item Line 18 calls Listing~\ref{validate} to validate the current sum and, if the sum is valid, line 19 sets the next index in the current square scratch memory, here represented by the variable \emph{tmp} to the current iteration index and increases the current size. Line 20 then pushes another call to Listing~\ref{allSquaresRecursive} onto the stack, and line 21 backtracks the current size.
\addtocounter{enumi}{5}
\item Regardless whether the validation test in line 18 succeeded, the current sum must be backtracked inside the same block where Listing~\ref{plus} was called. Line 24 accomplishes that with a balancing call to Listing~\ref{minus}.
\end{enumerate}

%--------------------------------------------------------------------------
\section{Computing all possible combination matrices for a row}

This section outlines a procedure that produces all combination matrices of self-derivation of a certain size for a particular row. The main idea relies on departing from a top row, which is a concatenation of transforms of the canonical form of a row $r$. If the row size is $n$, and the problem size is $m$, then the size of the top row is $m \times n$. In terms of derivation theory, the top row is completely linearized, and each of its $m$ transforms of the row $r$ will constitute a column of the combination matrix, if a solution for the top exists. The top itself is not part of the combination matrix, but rather the linearization thereof. It is, nonetheless, the point of departure of the main algorithm in this implementation. The combination matrix per se consists of a semi-magic square of size $m$ by $m$, where each column in the square defines a partition of the transform of $r$ for the corresponding section of the top. The last component in this view of a combination matrix of self-derivation are the transforms of the row $r$ that can be derived from the top row as a whole from the integer partitions given by the rows of the semi-magic square. These derived rows are a column vector of size $m$ which are called the sides of the combination matrix.

\begin{example}
Let $S = \{ 3, 8, 1, 0, 9, 6, 4, 7, 10, 5, 2, 11 \}$ as in Ex.~\ref{topSquareSideExample} and consider the combination matrix of self-derivation in Eq.~\ref{topSquareSideEquation}. In it, the top vector is $[\T_7(S) | \R\T_2\I(S)]$, the side vector is $[S | \T_9\I(S)]^T$, and the semi-magic square is

	\begin{equation}
        \left[
        \begin{array}{c|c}
            6 & 6 \\
            \hline
            6 & 6
        \end{array}
        \right] \enspace.
    \end{equation}
    
The row $S$ is not in its canonical form. An application of Listing~\ref{getCanonicalForm} reveals that the canonical form of $S$ is in fact the row $r = \{0, 3, 6, 11, 8, 5, 7, 10, 1, 2, 9, 4\}$, so that $S = RT_{11}(r)$.
\end{example}

\begin{theorem}
	\label{topSquareSideTheorem}
	Let $r$ be a row. If a  solution exists for a combination of top, side and square, then it is unique.
	\begin{proof}
	Suppose there exist two different solutions for the same combination of top, side and square. Then each solution comprises a combination matrix of self-derivation, say $M_1$ and $M_2$. By assumption $M_1 \ne M_2$. Now consider the linearized top and the first row of $M_1$, which is a transform of $r$, say $S_1(r)$. Since $M_1$ is a solution, when $S_1(r)$ is partitioned using the partition scheme given by the first row of the square, each partition of $S_1(r)$ fits exactly under each column of the top. Each column of the top is totally ordered, and so is each partition of $S_1(r)$. So there is only one way in which one can fit under another. The same reasoning applies to the first row of $M_2$, and to all subsequent rows of $M_1$ and $M_2$. Hence it must be that $M_1 = M_2$ and the solution is unique, as desired.
	\end{proof}
\end{theorem}

\begin{corollary}
	\label{topSquareSideCorollary}
	Let $r$ be a row. If a  solution exists for a combination of top, side and square, then the set of permutations of the side vector form an equivalence class of solutions.
	\begin{proof}
		The identity permutation of the side is essentially the same combination matrix, hence a solution. Reordering the entries of the side and applying Th.~\ref{topSquareSideTheorem} shows that a permutation of the side is also a solution. Let the problem size be $m$ and regard the side as a vector of indices with entries in $\mathbb{Z} / m \mathbb{Z}$. Then transitivity comes from the fact that $\mathbb{Z} / m \mathbb{Z}$ is a subgroup of $S_m$, that is, composition of permutations of the side vector are also a solution.
	\end{proof}
\end{corollary}

\begin{corollary}
    Let $r$ be a row, let the problem size be equal to $m$, and regard the top vector as the direct product of $m$ copies of $G_r$, the group of $RT_nI$-transforms of $r$. If a solution exists for a combination of top, side and square, then right-multiplying the solution by an element of $G_r$ represents a group action that induces an equivalence class of solutions. In particular, this equivalence class preserves the structure of the semi-magic square.
    \begin{proof}
    \end{proof}
\end{corollary}

%--------------------------------------------------------------------------
\subsection{Computing the side and top rows of a combination matrix}

As described above, the side and top vectors are key components in this implementation. Even though the side and the top are both vectors of length equal to the problem size, and they are both vectors of $RT_nI$ transforms of a row, there are some important distinctions between them. The most relevant distinction is that the top vector is used to define the input of a problem, whereas the side vector is used to compute a solution. In derivation theory words, the top vector is the linearization of the combination matrix, and each element in the side vector is a transform of the row $r$ that can be derived from from the top. Another fundamental distinction is that the contents of a side are permutable by Corollary~\ref{topSquareSideCorollary}, whereas the contents of the top are usually not. Even though there are permutations of the top vector that yield equivalent solutions, those are special cases and will be discussed in more detail in the next section. Lastly, like Listing~\ref{allSquaresRecursive}, the algorithm presented in Listing~\ref{allSidesRecursive} below also facilitates understanding of Listing~\ref{allSolutionsRecursive}, but it is not used in computing combination matrices of self-derivation. The algorithm described in Listing~\ref{allTopsRecursive}, on the other hand, is not only used in this implementation, but will also be the subject of future research.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all side vectors of a certain size.},label={allSidesRecursive}]
void allSidesRecursive(number *tmp, number currentSize, number problemSize, range classSize, FILE *file) {
    if (currentSize == problemSize) {
        fwrite(tmp, sizeof(number), problemSize, file);
        return;
    }

    number start = currentSize == 0 ? 0 : tmp[currentSize - 1];

    for (range i = start; i < classSize; ++i) {
        tmp[currentSize++] = i;
        allSidesRecursive(tmp, currentSize, problemSize, classSize, file);
        currentSize--;
    }
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are some pre-allocated scratch memory with size equal to the problem size, the current size of the vector, the problem size itself, the size of the row class, and a pointer to a C-style FILE data structure.
\item Line 2 is the base case of the recursion, and simply checks that the current size of the vector has already reached the problem size. If so, line 3 writes the contents of the scratch memory contiguously to the provided FILE handle and line 4 returns control to the caller.
\addtocounter{enumi}{4}
\item Line 7 is a similar mechanism to that described in line 12 of Listing~\ref{allSquaresRecursive}. Like the latter, its purpose is to avoid permutations of the size vector by forcing upon them being nondecreasing sequences of indices into the row class array. It will be shown in Listing~\ref{allSolutionsRecursive} that size vectors can actually be strictly increasing sequences.
\addtocounter{enumi}{1}
\item Line 9 begins iteration from the start index computed in line 7, until the last index possible, which is the size of the row class minus one. Line 10 sets the scratch memory's entry at the current size to the current index of iteration and increases the current size. Line 11 pushes onto the call stack another call to Listing~\ref{allSidesRecursive}, and line 12 backtracks by decreasing the current size, thus ensuring that all nondecreasing sequences of indices in the range from zero to row class size minus one are seen and written to the provided FILE.
\end{enumerate}

In this implementation, tops are pre-computed and saved to a file. This is a two-edged sword, as it increases speed at the expense of risking some potentially prohibitive file sizes. Let $r$ be a row of size $n$, let $c$ be the size of its row class, and let $m$ be a problem size. Then the number of all possible tops is $c^m$, which can be an incredibly large number. If $r$ is a 12-tone row that is not retrograde or retrograde inverse-invariant, then $c = 48$. The number of all possible $4 \times 4$ tops is then $48^4 = 5308416$. For music composition applications, $m = 4$ is a rather small number. A composer may well be interested in combination matrices of sizes up to $n$, hence reducing the number of tops into smaller equivalence classes is of utmost importance. Under the action of $RT_nI$, the number of tops can be reduced substantially, but this reduction is asymptotically irrelevant as row size and problem size grow. In other words, dealing with large $n$ and $m$ can be a very difficult problem. On the bright side, this analysis shows that solutions do exist in abundance, however difficult they may be to compute.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all top vectors of a certain size.},label={allTopsRecursive}]
void allTopsRecursive(number *tmp, number currentSize, number problemSize, range classSize, FILE *file) {
    if (currentSize == problemSize) {
        fwrite(tmp, sizeof(number), problemSize, file);
        return;
    }

    if (currentSize == 0)
        tmp[currentSize++] = 0;

    for (range i = 0; i < classSize; ++i) {
        tmp[currentSize++] = i;
        allTopsRecursive(tmp, currentSize, problemSize, classSize, file);
        currentSize--;
    }
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the memory address of some scratch memory space, pre-allocated with size equal to the problem size, the current size of the top, the problem size, the row class size, and a pointer to a FILE where the tops should be saved.
\item Line 2 handles the base case of the recursion, line 3 writes the contents of the current top to the FILE, and line 4 returns.
\addtocounter{enumi}{5}
\item Line 7 restricts the number of tops that will be computed by enforcing in line 8 that the first element of the top vector be always zero. If the problem size is $m$ and the class size is $c$, then Listing~\ref{allTopsRecursive} effectively computes $c^{m - 1}$ tops. It will be shown in the next section how all equivalence classes of tops under the action of $RT_nI$ can be computed departing from $c^{m - 1}$ elements.
\addtocounter{enumi}{2}
\item In line 10, the for-loop always starts from zero, since from the second element to the last, all possibilities are needed. Lines 11 to 13 describe the same backtracking recursive procedure in other algorithms already discussed above.
\end{enumerate}


Similarly to Listing~\ref{writeAllPartitions}, Listing~\ref{writeAllTops} wraps around Listing~\ref{allTopsRecursive} to save a file in the same location where the the main executable is built, so the details are omitted. Unlike Listing~\ref{writeAllPartitions}, however, the output of Listing~\ref{writeAllTops} can be a very large file. Suppose $r$ is a row of size $n = 12$, its row class has size $c = 48$, and the problem size is $m = 8$. Since a number of type char requires one byte of memory, the output of Listing~\ref{writeAllTops} would be a file of size $c^{m - 1} = 546.75$ Gigabytes.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Writing all tops to a file.},label={writeAllTops}]
void writeAllTops(number problemSize, range classSize) {
    char fileName[NAME_SIZE];
    sprintf(fileName, TOPS_FILE, problemSize, classSize);
    FILE *file = fopen(fileName, "wb");

    number *tmp = malloc(problemSize * sizeof(number));
    allTopsRecursive(tmp, 0, problemSize, classSize, file);

    free(tmp);
    fclose(file);
}
\end{lstlisting}

The same applies to Listing~\ref{readAllTops}, whose details are omitted for being similar to Listing~\ref{readAllPartitions} above, including the way Listing~\ref{readAllTops} generates a new file if none has been already created.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Reading all tops from a file.},label={readAllTops}]
number *readAllTops(length *numTops, number problemSize, range classSize) {
    char fileName[NAME_SIZE];
    sprintf(fileName, TOPS_FILE, problemSize, classSize);

    number *allTops = readFile(fileName, numTops, problemSize);

    if (allTops == NULL) {
        printf("Writing top combos file...\n");
        writeAllTops(problemSize, classSize);
        allTops = readFile(fileName, numTops, problemSize);
    }

    return allTops;
}
\end{lstlisting}

%--------------------------------------------------------------------------
\subsection{Writing a solution as text}

The main algorithm in this implementation writes to a file the combination matrices of self-derivation computed from a provided set of tops. It writes them to a provided file in a format that is readily useable for music composition, unless otherwise specified. It takes as input a significant amount of pre-computed data which can be shared between several threads of execution, as well many pointers to scratch memory addresses that must be allocated for each thread. Both common and thread-specific data are organized into data structures to reduce the number of parameters necessary for each call. These data structures, as well as the text formatting of the output will be discussed in this section.

Listing~\ref{threadCommonDataStructure} below is a data structure where all members are immutable, so is safe to shares between different threads of execution. Some members are common to a particular row, namely the memory address and size of the row class, the retrograde and retrograde inverse maps addresses, which will be discussed in the next section, the row size, and whether it is retrograde or retrograde inverse-invariant. All other members are common to all rows of a particular size $n$, given a problem size $m$. These members are namely the memory address and size of all partitions read from the partitions file, the memory address and size of all tops read from the tops file, and the problem size itself.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Defining a data structure to hold thread-common data.},label={threadCommonDataStructure}]
typedef struct {
    number *rowClass, *rMap, *riMap, *allPartitions, *allTops;
    length numPartitions, numTops;
    range topSize, classSize;
    number problemSize, rowSize, isInvariant;
} common_data;
\end{lstlisting}

Listing~\ref{threadSpecificDataStructure} below, on the other hand, cannot be shared between different threads of execution, as it mostly contains allocated scratch memory space to be used in a call to Listing~\ref{allSolutionsRecursive}, which computes all solutions for a given top. The members are, in order, the scratch memory for the size vector, the current top being used as input, the memory address for a stack of tops that will be needed by Listing~\ref{allSolutionsRecursive}, the current sum of the semi-magic square columns, the scratch memory for the semi-magic square itself, and lastly a variable to store the number of solutions obtained by the top at hand.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Defining a data structure to hold thread-specific data.},label={threadSpecificDataStructure}]
typedef struct {
    number *tmpSide, *currentTop, *tmpTops, *currentSum;
    length *tmpSquare;
    length counter;
} thread_data;
\end{lstlisting}

Listing~\ref{writeRow} is used in Listing~\ref{writeSolution} as a subroutine to write as text an entire solution line-by-line. The lines in the solution include the top line, as well as one line for each entry in the side vector.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Writing a single row from a combination matrix.},label={writeRow}]
void writeRow(const number *row, number rowSize, range topSize, bool newLine, FILE *file) {
    for (range i = 0; i < topSize; ++i) {
        if (i > 0 && i % rowSize == 0)
            write(file, "| ");

        if (row[i] < 0)
            write(file, "   ");
        else if (row[i] < 10)
            write(file, "%i  ", row[i]);
        else
            write(file, "%i ", row[i]);
    }

    if (newLine)
        write(file, "\n");
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the combination matrix row at hand, which includes the top line. These rows have the same length as the top row. Rows that are derived from the top, however, will have nonnegative entries whenever those entries align with the top's current index, and minus one otherwise. The row size, which is used to add separators at each of the top's columns, the top size, a boolean to indicate whether a new line character should be included after the combination matrix, and the address of a C-style FILE data structure.
\item Line 2 iterates over the top's length and line 3 checks if the current index of iteration has reached the boundary of a column. If so, line 4 will write a separator character and a space.
\addtocounter{enumi}{3}
\item Line 6 checks if the current row's entry is less than zero, in which case there is nothing to align with the top, hence line 7 writes three spaces. Line 8 checks if the current entry is less than ten, in which case line 9 writes a single-character number and two spaces. If line 10 is reached, then the current entry has two characters, so line 11 lines the two-digit number and a single space.
\addtocounter{enumi}{7}
\item Line 14 checks if a new line character was requested and, if so, line 15 writes one to the file.
\end{enumerate}

The algorithm for converting a solution into text is presented below in Listing~\ref{writeSolution}. A text solution consists of the solution number within the thread-specific context, and all the rows appended using calls to Listing~\ref{writeRow}. If a single thread is used, then the solution number is unique within the set of all solutions, otherwise it is only unique within the text file created by the thread the processed the solution. The rows of the combination matrix are prepended by their side vector index, and appended by their square row index, which is an index into the array of all integer partitions of size $n$, with entries in the range $[0, n - 1]$, as previously discussed.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Writing an entire solution.},label={writeSolution}]
void writeSolution(thread_data *d, common_data *cd, FILE *solutionsFile) {
    write(solutionsFile, "Solution %lu:\n\n     ", d->counter);
    writeRow(d->tmpTops, cd->rowSize, cd->topSize, true, solutionsFile);

    for (number i = 0; i < cd->problemSize; ++i) {
        range topIndex = 0;
        number rowIndex = 0;
        const number *p = &cd->allPartitions[d->tmpSquare[i] * cd->problemSize];
        const number *r = &cd->rowClass[d->tmpSide[i] * cd->rowSize];
        memset(d->currentTop, -1, cd->topSize * sizeof(number));

        for (number j = 0; j < cd->problemSize; ++j) {
            number pj = p[j];

            for (range k = topIndex; k < topIndex + cd->rowSize; ++k) {
                if (pj == 0)
                    break;

                if (d->tmpTops[k] == r[rowIndex]) {
                    d->currentTop[k] = r[rowIndex];
                    rowIndex++;
                    pj--;
                }
            }

            topIndex += cd->rowSize;
        }

        if (d->tmpSide[i] < 10)
            write(solutionsFile, "%i  | ", d->tmpSide[i]);
        else
            write(solutionsFile, "%i | ", d->tmpSide[i]);

        writeRow(d->currentTop, cd->rowSize, cd->topSize, false, solutionsFile);
        write(solutionsFile, "| %lu\n", d->tmpSquare[i]);
    }

    write(solutionsFile, "\n");
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the address of a thread-specific data structure, the address of a thread-common structure, and a pointer to a C-style FILE structure.
\item Line 2 writes the solution number within the current thread context. It also writes an additioinal line break, and five spaces, since the next line to be written is the top vector, which is not prepended by a side vector entry like the other derived rows. Line 3 then calls Listing~\ref{writeRow} to write the top vector, using the fact that the latter is stored as the bottommost element of the \emph{tmpTops} stack, whose details are deferred until the next section. 
\addtocounter{enumi}{2}
\item Line 5 iterates over the problem size, which is precisely the number of derived rows that combine to form a combination matrix. The thread-specific data structure provided as input contains a schematic solution, given by indices into various arrays found in the thread-common data structure. Therefore each derived row must be constructed before being written. Line 6 is then an index into the top vector, and line 7 is an index into the derived row. Line 8 is the address of the semi-magic square row within all the integer partitions, and line 9 is the address of the derived row within the row class. The memory address used to compute the spelled-out derived row is a reused scratch space, hence it is re-initialized at every iteration of the for-loop in line 5. Line 10 fills this scratch space with minus ones, as negative entries are skipped in Listing~\ref{writeRow}.
\addtocounter{enumi}{6}
\item Line 12 too iterates over the problem size, only this time regarding each column of the semi-magic square. Line 13 simply stores the integer partition value for the current iteration in a variable for convenience. This value is effectively the cell of the semi-magic square at row \emph{i} and column \emph{j}.
\addtocounter{enumi}{2}
\item The innermost for-loop in line 15 starts from the last top index and iterates $n$ times, where $n$ is the row size, and its body is responsible for matching the next \emph{pj} entries in the derived row against the entire \emph{j}\textsuperscript{th} column in the top vector, which has size $n$. Line 16 checks if all \emph{pj} entries have been matched, in which case line 17 breaks the for-loop.
\addtocounter{enumi}{2}
\item Line 19 checks if the derived row's entry at the current row index aligns with the current top column at the index of iteration given in line 15. If so, line 20 updates the scratch memory that will be used to write the derived row, line 21 increments the row index, and line 22 decrements \emph{pj}, which at each iteration represents the number of elements in the current square cell that still need to be matched.
\addtocounter{enumi}{6}
\item Line 25 increments the current top index by $n$ at each iteration of the for-loop in line 12, needed in order to traverse the top vector column-by-column.
\addtocounter{enumi}{1}
\item Line 27 checks if the current side vector index is less than ten, that is, if it has a single digit and, if so, line 28 prepends to the derived row line the side index, followed by two spaces and a separator. If the side index requires two digits, then line 30 prepends the side index followed by a single spaces and a separator.
\addtocounter{enumi}{4}
\item Line 32 calls Listing~\ref{writeRow} to write the computed derived row without a line break. Line 33 then prepends to the line the current square row index and a new line character.
\addtocounter{enumi}{3}
\item Line 36 simply separates this solution from the next with an additional line break.
\end{enumerate}

\begin{example}
	Below is a sample output of Listing~\ref{writeSolution}. In it, the row $r = \{0, 1, 4, 2, 5, 3\}$ is a 6-tone row that is not retrograde or retrograde inverse-invariant. The top row is the vector $\{T_0(r), RT_3I(r), T_0I(r)\}$. The side vector is equal to $\{21, 16, 19\} = \{RT_3I(r), RT_1(r), RT_4(r)\}$. The semi-magic square is the vector $\{8, 13, 17\}$. These are indices into the array of all partitions of six, that can be inferred from the combination matrix to be the square
	
	\begin{equation}
        \left[
        \begin{array}{c|c|c}
            1 & 3 & 2 \\
            \hline
            2 & 2 & 2 \\
            \hline
            3 & 1 & 2
        \end{array}
        \right] \enspace.
    \end{equation}
\end{example}

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize,numbers=none]
Solution 610:

     0  1  4  2  5  3  | 0  4  1  5  2  3  | 0  5  2  4  1  3  
21 | 0                 |    4  1  5        |       2        3  | 8
16 |    1           3  | 0           2     |    5     4        | 13
19 |       4  2  5     |                3  | 0           1     | 17
\end{lstlisting}

%--------------------------------------------------------------------------
\subsection{Computing all possible solutions for a given combination matrix}

The algorithm presented in Listing~\ref{allSolutionsRecursive} is the main procedure in this implementation for computing solutions to the problem of self-derivation. Like other algorithms described in the previous sections, it is a recursive backtracking algorithm. It utilizes Listing~\ref{matchRowWithTop} as a subroutine to test if the a given representative of a row class can be matched with the top row. Listing~\ref{matchRowWithTop} is very similar to the first inner for-loop in Listing~\ref{writeSolution} in that it tries to match a transform of the row $r$ against a top vector, and that matching is done column-by-column, using the partition scheme given by the current square row. The main difference between Listing~\ref{writeSolution} and Listing~\ref{matchRowWithTop} lies in the fact that the top row is not immutable. Rather, it is some scratch memory space that gets changed every time Listing~\ref{matchRowWithTop} is called. Another key difference is the fact that Listing~\ref{matchRowWithTop} can fail to produce a match, whereas Listing~\ref{writeSolution} is only called once a solution already exists for all derived rows.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Matching a representative of a row class with a given top vector.},label={matchRowWithTop}]
bool matchRowWithTop(number *top, const number *row, const number *partitions, number problemSize, number rowSize) {
    range topIndex = 0;
    number rowIndex = 0;

    for (number i = 0; i < problemSize; ++i) {
        number p = partitions[i];

        for (range j = topIndex; j < topIndex + rowSize; ++j) {
            if (p == 0)
                break;

            if (top[j] == row[rowIndex]) {
                top[j] = -1;
                rowIndex++;
                p--;
            }
        }

        if (p > 0)
            return false;

        topIndex += rowSize;
    }

    return rowIndex == rowSize;
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are a memory address that holds some scratch space with size equal to the top size, the address of the transform of the row which the algorithm will try to match with the top, the address of the integer partition to be used, that is, a row from the semi-magic square, the problem size, and the row size.
\item Like lines 6 and 7 in Listing~\ref{writeSolution}, lines 2 and 3 here are indices into the top vector and row transform. 
\addtocounter{enumi}{2}
\item Line 5 iterates over the problem size, that is, over the number of columns in the top vector, similarly to line 12 in Listing~\ref{writeSolution}. Line 6 stores in a variable the current square cell value, and the use of variable \emph{p} here is identical to the use of variable \emph{p} in Listing~\ref{writeSolution}.
\addtocounter{enumi}{2}
\item The inner for-loop in line 8, as well as the check in lines 9 and 10 are identical to lines 15 to 17 in Listing~\ref{writeSolution}.
\addtocounter{enumi}{3}
\item Line 12 tests that the \emph{j}\textsuperscript{th} entry in the top vector matches the row transform at the current row index. Unlike Listing~\ref{writeSolution}, the top vector may not be unaltered. If the \emph{j}\textsuperscript{th} entry in the top vector was already matched to a different transform of the row $r$ in a previous call to Listing~\ref{matchRowWithTop}, then the \emph{j}\textsuperscript{th} entry in the top vector will have been set to minus one, and Listing~\ref{matchRowWithTop} will fail. Otherwise, line 13 will set the \emph{j}\textsuperscript{th} entry in the top vector to minus one, which differs from Listing~\ref{writeSolution} in the sense that the latter sets a scratch memory space that had previously initialized with minus ones to the the corresponding entry in the row transform. Line 14 increases the row index, and line 15 decreases \emph{p}, similarly to what Listing~\ref{writeSolution} does in lines 21 and 22.
\addtocounter{enumi}{6}
\item Line 19 checks that all \emph{p} elements from the row transform starting at row index have been matched with the current top vector column. If not, line 20 returns false.
\addtocounter{enumi}{2}
\item If line 22 is reached, then the top index is increased by the row size, like line 25 in Listing~\ref{writeSolution}, and the algorithm moves to the next top vector column.
\addtocounter{enumi}{2}
\item If line 25 is reached, then the row transform has been matched successfully to all top vector columns. Still, the algorithm performs a sanity check and confirms that all row elements have been indeed matched by comparing the current row index with the row size.
\end{enumerate}

Listing~\ref{allSolutionsRecursive} combines Listing~\ref{allSidesRecursive} and Listing~\ref{allSquaresRecursive} to compute all possible solutions for a given top. The general idea is to, for each potential row of a semi-magic square, try to match a transform of the row $r$ with the current top using Listing~\ref{matchRowWithTop}. If that succeeds, Listing~\ref{allSolutionsRecursive} recurses then backtracks, thus covering all of the row class and all of the partitions. Side vectors are not computed directly, but rather as a side effect of matching transforms of $r$ with the top. The side vector is still maintained as the algorithm recurses, as it is crucial for avoiding permutations of the rows, as previously discussed, and is also used in Listing~\ref{writeSolution} to label each derived row in the text output of a solution.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Recursively computing all solutions for a top vector of a certain size.},label={allSolutionsRecursive}]
void allSolutionsRecursive(thread_data *d, common_data *cd, FILE *solutionsFile, number currentSize) {
    if (currentSize == cd->problemSize) {
        d->counter++;
        writeSolution(d, cd, solutionsFile);
        return;
    }

    length start = 0;

    if (currentSize > 0) {
        start = d->tmpSquare[currentSize - 1];
        memcpy(&d->tmpTops[currentSize * cd->topSize], d->currentTop, cd->topSize * sizeof(number));
    }

    for (length i = start; i < cd->numPartitions; ++i) {
        const number *p = &cd->allPartitions[i * cd->problemSize];
        plus(d->currentSum, p, cd->problemSize);

        if (validate(d->currentSum, cd->problemSize, cd->rowSize)) {
            d->tmpSquare[currentSize] = i;
            number rowStart = 0;

            if (currentSize > 0 && start == i)
                rowStart = d->tmpSide[currentSize - 1] + 1;

            for (range j = rowStart; j < cd->classSize; ++j) {
                const number *r = &cd->rowClass[j * cd->rowSize];

                if (matchRowWithTop(d->currentTop, r, p, cd->problemSize, cd->rowSize)) {
                    d->tmpSide[currentSize++] = j;
                    allSolutionsRecursive(d, cd, solutionsFile, currentSize);
                    currentSize--;
                }

                memcpy(d->currentTop, &d->tmpTops[currentSize * cd->topSize], cd->topSize * sizeof(number));
            }
        }

        minus(d->currentSum, p, cd->problemSize);
    }
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the memory address of the thread-specific data, the memory address of the thread-common data, a pointer to a C-style FILE data structure, and the current size of the call stack.
\item Line 2 deals with the base case of the recursion by testing whether the current size has reached the problem size. If so, line 3 increases the thread-specific solution counter, line 4 calls Listing~\ref{writeSolution} to write the solution to the provided FILE, and line 5 returns.
\addtocounter{enumi}{5}
\item Line 8 initializes a variable for where iteration of integer partition rows should start, similarly to line 7 in Listing~\ref{allSquaresRecursive}.
\addtocounter{enumi}{1}
\item Line 10 tests if the current size is greater than zero and, if so, line 11 sets the start value to the last row appended to the current semi-magic square, similarly to what line 12 in Listing~\ref{allSquaresRecursive} does, and line 12 here pushes onto the top history stack the current top. As derived rows are added to form a solution, the state of the current sum of square columns is always easy to backtrack by subtracting from the current sum array the last integer partition row that was appended to the square. Backtracking the current top, on the other hand, is more difficult. Every time a derived row is successfully matched against the current top, the entries where they align according to the square row at hand will be set to minus one in the current top. If all derived rows are matched and a solution is found, the entire current top scratch memory will contain only minus ones. Therefore backtracking the current top requires maintaining its history every time Listing~\ref{matchRowWithTop} succeeds and a new call to Listing~\ref{allSolutionsRecursive} is pushed onto the call stack.
\addtocounter{enumi}{4}
\item Lines 15 to 17 do exactly what lines 14 to 16 do in Listing~\ref{allSquaresRecursive}.
\addtocounter{enumi}{3}
\item Similarly, lines 19 and 20 are identical to lines 18 and 19 in Listing~\ref{allSquaresRecursive}. At this point, the current sum of square columns have been validated and a new integer partition row has been appended to the square. With an integer partition row and a current top in place, the algorithm now searches for a representative of the row class that will fit under the current top given the scheme provided by the integer partition. Line 21 then declares a variable to represent what the start index of iteration over the representatives of the row class should be.
\addtocounter{enumi}{3}
\item The rows of the square, seen as indices into the array of all integer partition rows, form a nondecreasing sequence. That is to avoid permutations of the square's rows, as by Cor.~\ref{topSquareSideCorollary} two squares with permuted rows are equivalent. Nonetheless, squares may have several repeated rows. One simple example is the square in which all entries are equal to $n / m$, where $n$ is the row size, $m$ is the problem size, and $m$ divides $n$. Line 23 tests for the case where the current square row is the same as the previous one, which can only be true if the current size is greater than zero. If that is the case, then the sequence of representatives of the row class that fall under the subsequence of repeated integer partition rows can be allowed to be nondecreasing, as well, to avoid permutations that would produce equivalent solutions. In fact, a stronger condition applies, and the sequence of representatives falling under repeated square rows can be strictly increasing. That is because the same representative of a row class cannot fit under the top row twice using the same integer partition row scheme. Line 24 then changes the start index of iteration over the representatives of the row class accordingly.
\addtocounter{enumi}{2}
\item Line 26 iterates over the representatives of a row class, according to the row start index declared in line 21, and line 27 stores in a variable the memory address of the representative being considered.
\addtocounter{enumi}{2}
\item Line 29 is a call to Listing~\ref{matchRowWithTop}. If it succeeds, line 30 sets the next row representative index in the side vector and increases the current size. Line 31 then pushes another call to Listing~\ref{allSolutionsRecursive} onto the stack, and line 32 backtracks the current size.
\addtocounter{enumi}{5}
\item Line 35 backtracks the current top to its previous state, using the top history stored in the top stack in line 12. Every call to Listing~\ref{matchRowWithTop} is matched with the backtracking procedure in line 35.
\addtocounter{enumi}{3}
\item Finally, line 39 backtracks the current sum of square columns with a balancing call to Listing~\ref{minus}, similarly to what Listing~\ref{allSquaresRecursive} does in its line 24.
\end{enumerate}

% TODO: If $m \nmid n$ and $n > 2$, then consider the square where all entries in all rows but the bottommost row are equal to $x = \lfloor n / m \rfloor$, and all entries in the bottommost row are equal to $x + 1$.

%--------------------------------------------------------------------------
\section{Creating work data for use in concurrent threads}

This section outlines the procedures used for allocating the data structures to be used as inputs to Listing~\ref{allSolutionsRecursive}. Pre-allocating and reusing scratch memory locations is absolutely critical for the performance of all algorithms described above. Unnecessary calls to allocate and deallocate memory can significantly increase the time it takes for Listing~\ref{allSolutionsRecursive} to execute as row size and problem size grow. Listing~\ref{createCommonData} describes how thread-common data is allocated, and every call to Listing~\ref{createCommonData} should be balanced with a call to Listing~\ref{destroyCommonData} when resources are no longer needed. Listing~\ref{createCommonData} allocates two arrays with size equal to the row class size. These are namely the retrograde and the retrograde inverse maps. As the name suggests, theses are mappings between indices within the row class. The retrograde map takes an element into its retrograde, and the retrograde inverse map takes an element into its retrograde inverse. These maps will be used in conjunction with Listing~\ref{unseen}, thus further details are deferred until the next section.

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Allocating thread-common data.},label={createCommonData}]
void createCommonData(common_data *cd, int argc, char *argv[]) {
    number problemSize = (number) strtol(argv[1], NULL, 10);
    number rowSize = argc - 2;
    number *row = malloc(rowSize * sizeof(number));

    for (number i = 0; i < rowSize; ++i)
        row[i] = (number) strtol(argv[i + 2], NULL, 10);

    cd->problemSize = problemSize;
    cd->rowSize = rowSize;
    cd->topSize = problemSize * rowSize;

    bool rInvariant = isRetrogradeInvariant(row, rowSize);
    bool riInvariant = isRetrogradeInverseInvariant(row, rowSize);

    cd->isInvariant = rInvariant || riInvariant;
    cd->rowClass = getRowClass(&cd->classSize, row, rowSize, cd->isInvariant);
    cd->rMap = malloc(cd->classSize * sizeof(number));
    cd->riMap = malloc(cd->classSize * sizeof(number));
    cd->allPartitions = readAllPartitions(&cd->numPartitions, problemSize, rowSize);
    cd->allTops = readAllTops(&cd->numTops, problemSize, cd->classSize);

    if (rInvariant) {
        for (int i = 0; i < rowSize; ++i)
            cd->rMap[i] = cd->rowClass[(i + 1) * rowSize - 1];

        for (int i = rowSize; i < cd->classSize; ++i)
            cd->rMap[i] = cd->rowClass[(i + 1) * rowSize - 1] + rowSize;
    } else {
        for (int i = 0; i < rowSize; ++i)
            cd->rMap[i] = cd->rowClass[(i + 1) * rowSize - 1] + rowSize;

        for (int i = rowSize; i < cd->classSize; ++i)
            cd->rMap[i] = cd->rowClass[(i + 1) * rowSize - 1];
    }

    for (int i = 0; i < cd->classSize; ++i)
        cd->riMap[i] = (cd->rMap[i] == 0 || cd->rMap[i] == rowSize)
                       ? modulo(cd->rMap[i] + rowSize, cd->classSize)
                       : modulo(-cd->rMap[i], cd->classSize);

    free(row);
}
\end{lstlisting}

\begin{enumerate}
\item The inputs are the memory address of a thread-common data structure, and the number of arguments provided in the command line, and the array of such arguments. Listing~\ref{createCommonData} allocates the internal pointers in a thread-common data structure, but also parses the command line inputs, which are a problem size and a row, separated by spaces. The row does not need to be in its canonical form.
\item Line 2 retrieves the problem size from the first element in arguments array. Note that the zeroth element is the application name. Line 3 computes then the row size, which is just the number of arguments minus two, namely the row size and the application name. Line 4 allocates some memory space which will be used to parse the row provided in the remaining arguments.
\addtocounter{enumi}{3}
\item Line 6 iterates through the row size and line 7 parses each row entry provided, storing them in the memory allocated in line 4.
\addtocounter{enumi}{2}
\item Line 9 updates the provided pointer to a thread-common data structure with the problem size, line 10 updates the row size, and line 11 computes and updates the top size.
\addtocounter{enumi}{3}
\item Line 13 is a call to Listing~\ref{isRetrogradeInvariant} to determine if the row is retrograde-invariant, and line 14 is similarly a call to Listing~\ref{isRetrogradeInverseInvariant} to determine if the row is retrograde inverse-invariant. Note that the row does not need to be in its canonical form when determining retrograde or retrograde inverse-invariance.
\addtocounter{enumi}{2}
\item Line 16 updates the data pointer with information whether the row is retrograde or retrograde inverse-invariance. The specific information whether retrograde invariance occurs under inversion or not will be needed to compute retrograde and retrograde inverse maps in Listing~\ref{createCommonData}, but will not be needed in the algorithms that depend on a thread-common data structure. Line 17 is a call to Listing~\ref{getRowClass}, which allocates and returns the memory address of the row class array. Line 18 allocates the memory that will hold the retrograde map, and line 19 allocates the memory that will hold the retrograde inverse map. Lines 20 and 21 are calls to respectively Listing~\ref{readAllPartitions} and Listing~\ref{readAllTops}, both returning allocated memory addresses.
\addtocounter{enumi}{6}
\item Line 23 tests if the row is retrograde-invariant and, if so, line 24 iterates over the size of the row, filling the first half of the retrograde map in line 25. Note that, since the row is retrograde-invariant, the size of the row class is twice the size of the row.
\addtocounter{enumi}{3}
\item Line 27 continues iterating over the class size, filling the second half of the retrograde map in line 28.
\addtocounter{enumi}{2}
\item If the row is retrograde inverse-invariant, line 30 iterates over the size of the row, filling the first half of the retrograde map in line 31. Note that here the first and second halves of the retrograde map are reversed in regard to the retrograde-invariant case, that is, line 31 does the same computation that line 28 does.
\addtocounter{enumi}{2}
\item Line 33 continues iterating over the class size, filling the second half of the retrograde map in line 34, with the same computation in line 25.
\addtocounter{enumi}{3}
\item Line 37 iterates over the entire size of the row class to set the values in the retrograde inverse map. Line 38 tests if the corresponding retrograde map entry contains the $T_0$ or the $T_0I$ transforms of the row, in which case line 39 assigns these indices such that $T_0 \mapsto T_0I$ and $T_0I \mapsto T_0$. If not, then line 40 assigns the other indices such that $T_x \mapsto T_{-x}$.
\addtocounter{enumi}{4}
\item Finally, line 42 deallocates the space created in line 4, as the original row can now be retrieved from the row class array.
\end{enumerate}

\begin{example}
\label{rMapExample}
Let $r$ be a retrograde-invariant row with size $n = 6$. Then the row class array computed by Listing~\ref{getRowClass} will contain a sequence of transforms of $r$ equal to $C = \{T_0, \cdots, T_5, T_0I, \cdots, T_5I\}$. The retrograde map of the row class of $r$ will be the sequence containing the last entry in each transform of $r$ in $C$. This sequence will always be equal to $C_R = \{3, 4, 5, 0, 1, 2, 9, 10, 11, 6, 7, 8\}$. Since $r$ is retrograde-invariant, the sequence $\{0, \cdots, 5\}$ of indices of $r$ maps to itself under the retrograde operator, that is, $R$ is the permutation $(0 \; 5) \; (1 \; 4) \; (2 \; 3)$ when seen as a permutation of indices. Since $r = RT_x(r)$ by assumption, $Tx$ must be a transposition that, seen as a permutation of pitch-classes, comprises solely 2-cycles. This is only possible if $x = 3$. Since $T_3 = (0 \; 3) \; (1 \; 4) \; (2 \; 5)$, the array given by $C_R$, when seen as a permutation of indices of the row class, is in fact the map
\begin{equation}
	T_0 \mapsto T_3, \cdots, T_5 \mapsto T_2, T_3I \mapsto T_0I, \cdots, T_5I \mapsto T_2I \enspace.
\end{equation}
Given an index in $C$, the retrograde map takes that index to another index in $C$ such that a transform of $r$ maps to itself under $RT_{n / 2}$. Let $C_I = \{6, 11, 10, 9, 8, 7, 0, 5, 4, 3, 2, 1\}$ be the array that maps a transform of $r$ in the row class array to its inverse. Seen as a permutation, $C_I = (0 \; 6) \; (1 \; 11) \; (2 \; 10) \; (3 \; 9) \; (4 \; 8) \; (5 \; 7)$. The retrograde inverse map is then the composition of $C_R$ with $C_I$, that is
\begin{equation}
	C_R \circ C_I = \{9, 8, 7, 6, 11, 10, 3, 2, 1, 0, 5, 4\} \enspace.
\end{equation}
\end{example}

\begin{example}
Let $r = \{0, 2, 3, 4, 5, 1\}$, with $n$, $C$ and $C_I$ as in Ex.~\ref{rMapExample}. Then $r$ is retrograde inverse-invariant. The sequence containing the last entry in each transform of $r$ in $C$ will depend on which $x$ satisfies $r = RT_xI(r)$. Since $T_xI$, seen as a permutation, must comprise only 2-cycles, $x$ is necessarily odd. In particular, $x = 1$ for this choice of $r$, but unlike retrograde maps, retrograde inverse maps depend on the row at hand. More precisely, on the transposition index in the operation that maps the row to itself. Here, $C_R = \{7, 8, 9, 10, 11, 6, 5, 0, 1, 2, 3, 4\}$ and thus
\begin{equation}
	C_R \circ C_I = \{5, 4, 3, 2, 1, 0, 7, 6, 11, 10, 9, 8\} \enspace.
\end{equation}
\end{example}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Deallocating thread-common data.},label={destroyCommonData}]
void destroyCommonData(common_data *cd) {
    free(cd->rowClass);
    free(cd->rMap);
    free(cd->riMap);
    free(cd->allPartitions);
    free(cd->allTops);
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Allocating thread-specific data.},label={createThreadData}]
void createThreadData(thread_data *d, common_data *cd) {
    d->counter = 0;
    d->tmpSide = malloc(cd->problemSize * sizeof(number));
    d->currentTop = malloc(cd->topSize * sizeof(number));
    d->tmpTops = malloc(cd->problemSize * cd->topSize * sizeof(number));
    d->currentSum = malloc(cd->problemSize * sizeof(number));
    d->tmpSquare = malloc(cd->problemSize * sizeof(length));
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={Deallocating thread-specific data.},label={destroyThreadData}]
void destroyThreadData(thread_data *d) {
    free(d->tmpSide);
    free(d->currentTop);
    free(d->tmpTops);
    free(d->currentSum);
    free(d->tmpSquare);
}
\end{lstlisting}

%--------------------------------------------------------------------------
\section{Defining a top-level procedure for computing all solutions for a given row class}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={},label={createSolutionsFile}]
FILE *createSolutionsFile(number *row, number problemSize, number rowSize, length startTop, length endTop) {
    char fileName[64];
    sprintf(fileName, "all_solutions_%i", problemSize);
    char offset = problemSize < 10 ? 15 : 16;

    for (number i = 0; i < rowSize; ++i) {
        sprintf(&fileName[offset], "_%i", row[i]);
        offset += row[i] < 10 ? 2 : 3;
    }

    sprintf(&fileName[offset], "_%lu_%lu.txt", startTop, endTop);

    return fopen(fileName, "wt");
}
\end{lstlisting}

\begin{enumerate}
\addtocounter{enumi}{1}
\item 
\end{enumerate}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={},label={}]
range getInverse(range num, number rowSize) {
    if (num == 0 || num == rowSize * 2)
        return num + rowSize;

    if (num == rowSize || num == rowSize * 3)
        return num - rowSize;

    if (num < rowSize * 2)
        return rowSize * 2 - num;

    return rowSize * 6 - num;
}
\end{lstlisting}

\begin{enumerate}
\addtocounter{enumi}{1}
\item 
\end{enumerate}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={},label={}]
range getReverse(range num, number rowSize) {
    return (num + rowSize * 2) % (rowSize * 4);
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={},label={}]
range getReverseInverse(range num, number rowSize) {
    return getInverse(getReverse(num, rowSize), rowSize);
}
\end{lstlisting}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={},label={}]
bool seen(const number *combo, common_data *cd) {
    number last = cd->problemSize - 1;
    bool I = (combo[last] % (cd->rowSize * 2)) > (cd->rowSize - 1);
    number T = combo[last] % cd->rowSize;
    range back, transform, offset;

    for (int i = 0; i <= last; ++i) {
        if (I) {
            back = getReverseInverse(combo[last - i], cd->rowSize);
            transform = modulo(back + T, cd->rowSize);
        } else {
            back = getReverse(combo[last - i], cd->rowSize);
            transform = modulo(back - T, cd->rowSize);
        }

        offset = (back / cd->rowSize) * cd->rowSize;

        if (combo[i] < transform + offset)
            return false;
        else if (combo[i] > transform + offset)
            return true;
    }

    return false;
}
\end{lstlisting}

\begin{enumerate}
\addtocounter{enumi}{1}
\item 
\end{enumerate}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={},label={unseen}]
bool unseen(const number *top, common_data *cd) {
    number last = cd->problemSize - 1;
    number offset = cd->rMap[top[last]];
    bool invert = offset >= cd->rowSize;

    if (invert)
        offset = cd->riMap[top[last]];

    for (number i = 1; i < cd->problemSize; ++i) {
        number front = top[i];
        number back = invert ? cd->riMap[top[last - i]] : cd->rMap[top[last - i]];

        if (back < cd->rowSize)
            back = modulo(back - offset, cd->rowSize);
        else {
            back = modulo(back - offset - cd->rowSize, cd->rowSize);
            back += cd->rowSize;
        }

        if (back > front)
            return true;
        else if (back < front)
            return false;
    }

    return true;
}
\end{lstlisting}

% 1. Compute the R or RI-transform of the top.
% 2. Transpose the above so it starts with zero.
% 3. Go from left to right and return true if:
%    3.1. There is an entry greater than the top or;
%    3.2. There are no entries less than the top, implying the top is R or RI-invariant.

\begin{enumerate}
\addtocounter{enumi}{1}
\item 
\end{enumerate}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={},label={fillTop}]
void fillTop(thread_data *d, common_data *cd, const number *combo) {
    for (number i = 0; i < cd->problemSize; ++i)
        memcpy(&d->currentTop[i * cd->rowSize],
               &cd->rowClass[combo[i] * cd->rowSize],
               cd->rowSize * sizeof(number));
}
\end{lstlisting}

\begin{enumerate}
\addtocounter{enumi}{1}
\item 
\end{enumerate}

%--------------------------------------------------------------------------
\begin{lstlisting}[caption={},label={writeSolutions}]
length writeSolutions(thread_data *d, common_data *cd, length startTop, length endTop) {
    length topCounter = 0;

    FILE *solutionsFile = createSolutionsFile(&cd->rowClass[0], cd->problemSize, cd->rowSize, startTop, endTop);

    for (range first = 0; first < cd->classSize; first += cd->classSize / 2) {
        for (length i = startTop; i < endTop; ++i) {
            number *combo = &cd->allTops[i * cd->problemSize];
            combo[0] = first;

            if (!cd->isInvariant && seen(combo, cd))
                continue;

            if (cd->isInvariant && !unseen(combo, cd))
                continue;

            fillTop(d, cd, combo);
            memcpy(d->tmpTops, d->currentTop, cd->topSize * sizeof(number));
            memset(d->currentSum, 0, cd->problemSize * sizeof(number));
            allSolutionsRecursive(d, cd, solutionsFile, 0);
            topCounter++;
        }
    }

    fclose(solutionsFile);

    return topCounter;
}
\end{lstlisting}

\begin{enumerate}
\addtocounter{enumi}{1}
\item 
\end{enumerate}

%--------------------------------------------------------------------------
\section{Defining a single and multi-threaded command line tools for computing all solutions for a given row and problem size}
